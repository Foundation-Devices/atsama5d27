/* automatically generated by rust-bindgen 0.68.1 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const FEATURE_ENABLED: u32 = 1;
pub const FEATURE_DISABLED: u32 = 0;
pub const DEFAULT_ENABLED: u32 = 1;
pub const DEFAULT_DISABLED: u32 = 0;
pub const ATCA_TA_SUPPORT: u32 = 0;
pub const ATCA_POST_DELAY_MSEC: u32 = 25;
pub const ATCA_PREPROCESSOR_WARNING: u32 = 0;
pub const CALIB_DELETE_EN: u32 = 0;
pub const MAX_PACKET_SIZE: u32 = 1072;
pub const MULTIPART_BUF_EN: u32 = 0;
pub const ATCA_ECC_SUPPORT: u32 = 1;
pub const ATCA_CA2_SUPPORT: u32 = 0;
pub const ATCA_CA_SUPPORT: u32 = 1;
pub const ATCA_HOSTLIB_EN: u32 = 0;
pub const ATCA_CHECK_PARAMS_EN: u32 = 1;
pub const ATCAB_AES_EN: u32 = 1;
pub const ATCAB_AES_GFM_EN: u32 = 1;
pub const ATCAB_AES_GCM_EN: u32 = 1;
pub const ATCAB_CHECKMAC_EN: u32 = 1;
pub const ATCAB_COUNTER_EN: u32 = 1;
pub const ATCAB_DERIVEKEY_EN: u32 = 1;
pub const ATCAB_ECDH_EN: u32 = 1;
pub const ATCAB_ECDH_ENC_EN: u32 = 1;
pub const ATCAB_GENDIG_EN: u32 = 1;
pub const ATCAB_GENKEY_EN: u32 = 1;
pub const ATCAB_GENKEY_MAC_EN: u32 = 1;
pub const ATCAB_HMAC_EN: u32 = 1;
pub const ATCAB_INFO_LATCH_EN: u32 = 1;
pub const ATCAB_KDF_EN: u32 = 1;
pub const ATCAB_LOCK_EN: u32 = 1;
pub const ATCAB_MAC_EN: u32 = 1;
pub const ATCAB_NONCE_EN: u32 = 1;
pub const ATCAB_PRIVWRITE_EN: u32 = 1;
pub const ATCAB_RANDOM_EN: u32 = 1;
pub const ATCAB_READ_EN: u32 = 1;
pub const ATCAB_READ_ENC_EN: u32 = 1;
pub const ATCAB_SECUREBOOT_EN: u32 = 1;
pub const ATCAB_SECUREBOOT_MAC_EN: u32 = 1;
pub const ATCAB_SELFTEST_EN: u32 = 1;
pub const ATCAB_SHA_EN: u32 = 1;
pub const ATCAB_SHA_HMAC_EN: u32 = 1;
pub const ATCAB_SHA_CONTEXT_EN: u32 = 1;
pub const ATCAB_SIGN_EN: u32 = 1;
pub const ATCAB_SIGN_INTERNAL_EN: u32 = 1;
pub const ATCAB_UPDATEEXTRA_EN: u32 = 1;
pub const ATCAB_VERIFY_EN: u32 = 1;
pub const ATCAB_VERIFY_EXTERN_EN: u32 = 1;
pub const ATCAB_VERIFY_MAC_EN: u32 = 1;
pub const ATCAB_VERIFY_STORED_EN: u32 = 1;
pub const ATCAB_VERIFY_VALIDATE_EN: u32 = 1;
pub const ATCAB_WRITE_EN: u32 = 1;
pub const ATCAB_WRITE_ENC_EN: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const ATCA_LIBRARY_VERSION_DATE: &[u8; 9] = b"20230908\0";
pub const ATCA_LIBRARY_VERSION_MAJOR: u32 = 3;
pub const ATCA_LIBRARY_VERSION_MINOR: u32 = 7;
pub const ATCA_LIBRARY_VERSION_BUILD: u32 = 0;
pub const ATCA_SUCCESS: u32 = 0;
pub const ATCA_CONFIG_ZONE_LOCKED: u32 = 1;
pub const ATCA_DATA_ZONE_LOCKED: u32 = 2;
pub const ATCA_WAKE_FAILED: i32 = -48;
pub const ATCA_CHECKMAC_VERIFY_FAILED: i32 = -47;
pub const ATCA_PARSE_ERROR: i32 = -46;
pub const ATCA_STATUS_CRC: i32 = -44;
pub const ATCA_STATUS_UNKNOWN: i32 = -43;
pub const ATCA_STATUS_ECC: i32 = -42;
pub const ATCA_STATUS_SELFTEST_ERROR: i32 = -41;
pub const ATCA_FUNC_FAIL: i32 = -32;
pub const ATCA_GEN_FAIL: i32 = -31;
pub const ATCA_BAD_PARAM: i32 = -30;
pub const ATCA_INVALID_ID: i32 = -29;
pub const ATCA_INVALID_SIZE: i32 = -28;
pub const ATCA_RX_CRC_ERROR: i32 = -27;
pub const ATCA_RX_FAIL: i32 = -26;
pub const ATCA_RX_NO_RESPONSE: i32 = -25;
pub const ATCA_RESYNC_WITH_WAKEUP: i32 = -24;
pub const ATCA_PARITY_ERROR: i32 = -23;
pub const ATCA_TX_TIMEOUT: i32 = -22;
pub const ATCA_RX_TIMEOUT: i32 = -21;
pub const ATCA_TOO_MANY_COMM_RETRIES: i32 = -20;
pub const ATCA_SMALL_BUFFER: i32 = -19;
pub const ATCA_COMM_FAIL: i32 = -16;
pub const ATCA_TIMEOUT: i32 = -15;
pub const ATCA_BAD_OPCODE: i32 = -14;
pub const ATCA_WAKE_SUCCESS: i32 = -13;
pub const ATCA_EXECUTION_ERROR: i32 = -12;
pub const ATCA_UNIMPLEMENTED: i32 = -11;
pub const ATCA_ASSERT_FAILURE: i32 = -10;
pub const ATCA_TX_FAIL: i32 = -9;
pub const ATCA_NOT_LOCKED: i32 = -8;
pub const ATCA_NO_DEVICES: i32 = -7;
pub const ATCA_HEALTH_TEST_ERROR: i32 = -6;
pub const ATCA_ALLOC_FAILURE: i32 = -5;
pub const ATCA_USE_FLAGS_CONSUMED: i32 = -4;
pub const ATCA_NOT_INITIALIZED: i32 = -3;
pub const ATCA_STATUS_AUTH_BIT: u32 = 64;
pub const ATCA_STATUS_AUTH_BIT_COMPLEMENT: i32 = -65;
pub const ATSHA204A: u32 = 0;
pub const ATECC108A: u32 = 1;
pub const ATECC508A: u32 = 2;
pub const ATECC608A: u32 = 3;
pub const ATECC608B: u32 = 3;
pub const ATECC608: u32 = 3;
pub const ATSHA206A: u32 = 4;
pub const TA100: u32 = 16;
pub const ECC204: u32 = 32;
pub const TA010: u32 = 33;
pub const ECC206: u32 = 34;
pub const RNG90: u32 = 35;
pub const SHA104: u32 = 36;
pub const SHA105: u32 = 37;
pub const SHA106: u32 = 38;
pub const ATCA_DEV_UNKNOWN: u32 = 126;
pub const ATCA_DEV_INVALID: u32 = 127;
pub const ATCA_POLLING_INIT_TIME_MSEC: u32 = 1;
pub const ATCA_POLLING_FREQUENCY_TIME_MSEC: u32 = 2;
pub const ATCA_POLLING_MAX_TIME_MSEC: u32 = 2500;
pub const ATCA_HAL_CONTROL_WAKE: u32 = 0;
pub const ATCA_HAL_CONTROL_IDLE: u32 = 1;
pub const ATCA_HAL_CONTROL_SLEEP: u32 = 2;
pub const ATCA_HAL_CONTROL_RESET: u32 = 3;
pub const ATCA_HAL_CONTROL_SELECT: u32 = 4;
pub const ATCA_HAL_CONTROL_DESELECT: u32 = 5;
pub const ATCA_HAL_CHANGE_BAUD: u32 = 6;
pub const ATCA_HAL_FLUSH_BUFFER: u32 = 7;
pub const ATCA_HAL_CONTROL_DIRECTION: u32 = 8;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYSCALL_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __GLIBC_LINUX_VERSION_CODE: u32 = 394240;
pub const SYS__sysctl: u32 = 156;
pub const SYS_accept: u32 = 43;
pub const SYS_accept4: u32 = 288;
pub const SYS_access: u32 = 21;
pub const SYS_acct: u32 = 163;
pub const SYS_add_key: u32 = 248;
pub const SYS_adjtimex: u32 = 159;
pub const SYS_afs_syscall: u32 = 183;
pub const SYS_alarm: u32 = 37;
pub const SYS_arch_prctl: u32 = 158;
pub const SYS_bind: u32 = 49;
pub const SYS_bpf: u32 = 321;
pub const SYS_brk: u32 = 12;
pub const SYS_capget: u32 = 125;
pub const SYS_capset: u32 = 126;
pub const SYS_chdir: u32 = 80;
pub const SYS_chmod: u32 = 90;
pub const SYS_chown: u32 = 92;
pub const SYS_chroot: u32 = 161;
pub const SYS_clock_adjtime: u32 = 305;
pub const SYS_clock_getres: u32 = 229;
pub const SYS_clock_gettime: u32 = 228;
pub const SYS_clock_nanosleep: u32 = 230;
pub const SYS_clock_settime: u32 = 227;
pub const SYS_clone: u32 = 56;
pub const SYS_clone3: u32 = 435;
pub const SYS_close: u32 = 3;
pub const SYS_close_range: u32 = 436;
pub const SYS_connect: u32 = 42;
pub const SYS_copy_file_range: u32 = 326;
pub const SYS_creat: u32 = 85;
pub const SYS_create_module: u32 = 174;
pub const SYS_delete_module: u32 = 176;
pub const SYS_dup: u32 = 32;
pub const SYS_dup2: u32 = 33;
pub const SYS_dup3: u32 = 292;
pub const SYS_epoll_create: u32 = 213;
pub const SYS_epoll_create1: u32 = 291;
pub const SYS_epoll_ctl: u32 = 233;
pub const SYS_epoll_ctl_old: u32 = 214;
pub const SYS_epoll_pwait: u32 = 281;
pub const SYS_epoll_pwait2: u32 = 441;
pub const SYS_epoll_wait: u32 = 232;
pub const SYS_epoll_wait_old: u32 = 215;
pub const SYS_eventfd: u32 = 284;
pub const SYS_eventfd2: u32 = 290;
pub const SYS_execve: u32 = 59;
pub const SYS_execveat: u32 = 322;
pub const SYS_exit: u32 = 60;
pub const SYS_exit_group: u32 = 231;
pub const SYS_faccessat: u32 = 269;
pub const SYS_faccessat2: u32 = 439;
pub const SYS_fadvise64: u32 = 221;
pub const SYS_fallocate: u32 = 285;
pub const SYS_fanotify_init: u32 = 300;
pub const SYS_fanotify_mark: u32 = 301;
pub const SYS_fchdir: u32 = 81;
pub const SYS_fchmod: u32 = 91;
pub const SYS_fchmodat: u32 = 268;
pub const SYS_fchown: u32 = 93;
pub const SYS_fchownat: u32 = 260;
pub const SYS_fcntl: u32 = 72;
pub const SYS_fdatasync: u32 = 75;
pub const SYS_fgetxattr: u32 = 193;
pub const SYS_finit_module: u32 = 313;
pub const SYS_flistxattr: u32 = 196;
pub const SYS_flock: u32 = 73;
pub const SYS_fork: u32 = 57;
pub const SYS_fremovexattr: u32 = 199;
pub const SYS_fsconfig: u32 = 431;
pub const SYS_fsetxattr: u32 = 190;
pub const SYS_fsmount: u32 = 432;
pub const SYS_fsopen: u32 = 430;
pub const SYS_fspick: u32 = 433;
pub const SYS_fstat: u32 = 5;
pub const SYS_fstatfs: u32 = 138;
pub const SYS_fsync: u32 = 74;
pub const SYS_ftruncate: u32 = 77;
pub const SYS_futex: u32 = 202;
pub const SYS_futex_waitv: u32 = 449;
pub const SYS_futimesat: u32 = 261;
pub const SYS_get_kernel_syms: u32 = 177;
pub const SYS_get_mempolicy: u32 = 239;
pub const SYS_get_robust_list: u32 = 274;
pub const SYS_get_thread_area: u32 = 211;
pub const SYS_getcpu: u32 = 309;
pub const SYS_getcwd: u32 = 79;
pub const SYS_getdents: u32 = 78;
pub const SYS_getdents64: u32 = 217;
pub const SYS_getegid: u32 = 108;
pub const SYS_geteuid: u32 = 107;
pub const SYS_getgid: u32 = 104;
pub const SYS_getgroups: u32 = 115;
pub const SYS_getitimer: u32 = 36;
pub const SYS_getpeername: u32 = 52;
pub const SYS_getpgid: u32 = 121;
pub const SYS_getpgrp: u32 = 111;
pub const SYS_getpid: u32 = 39;
pub const SYS_getpmsg: u32 = 181;
pub const SYS_getppid: u32 = 110;
pub const SYS_getpriority: u32 = 140;
pub const SYS_getrandom: u32 = 318;
pub const SYS_getresgid: u32 = 120;
pub const SYS_getresuid: u32 = 118;
pub const SYS_getrlimit: u32 = 97;
pub const SYS_getrusage: u32 = 98;
pub const SYS_getsid: u32 = 124;
pub const SYS_getsockname: u32 = 51;
pub const SYS_getsockopt: u32 = 55;
pub const SYS_gettid: u32 = 186;
pub const SYS_gettimeofday: u32 = 96;
pub const SYS_getuid: u32 = 102;
pub const SYS_getxattr: u32 = 191;
pub const SYS_init_module: u32 = 175;
pub const SYS_inotify_add_watch: u32 = 254;
pub const SYS_inotify_init: u32 = 253;
pub const SYS_inotify_init1: u32 = 294;
pub const SYS_inotify_rm_watch: u32 = 255;
pub const SYS_io_cancel: u32 = 210;
pub const SYS_io_destroy: u32 = 207;
pub const SYS_io_getevents: u32 = 208;
pub const SYS_io_pgetevents: u32 = 333;
pub const SYS_io_setup: u32 = 206;
pub const SYS_io_submit: u32 = 209;
pub const SYS_io_uring_enter: u32 = 426;
pub const SYS_io_uring_register: u32 = 427;
pub const SYS_io_uring_setup: u32 = 425;
pub const SYS_ioctl: u32 = 16;
pub const SYS_ioperm: u32 = 173;
pub const SYS_iopl: u32 = 172;
pub const SYS_ioprio_get: u32 = 252;
pub const SYS_ioprio_set: u32 = 251;
pub const SYS_kcmp: u32 = 312;
pub const SYS_kexec_file_load: u32 = 320;
pub const SYS_kexec_load: u32 = 246;
pub const SYS_keyctl: u32 = 250;
pub const SYS_kill: u32 = 62;
pub const SYS_landlock_add_rule: u32 = 445;
pub const SYS_landlock_create_ruleset: u32 = 444;
pub const SYS_landlock_restrict_self: u32 = 446;
pub const SYS_lchown: u32 = 94;
pub const SYS_lgetxattr: u32 = 192;
pub const SYS_link: u32 = 86;
pub const SYS_linkat: u32 = 265;
pub const SYS_listen: u32 = 50;
pub const SYS_listxattr: u32 = 194;
pub const SYS_llistxattr: u32 = 195;
pub const SYS_lookup_dcookie: u32 = 212;
pub const SYS_lremovexattr: u32 = 198;
pub const SYS_lseek: u32 = 8;
pub const SYS_lsetxattr: u32 = 189;
pub const SYS_lstat: u32 = 6;
pub const SYS_madvise: u32 = 28;
pub const SYS_mbind: u32 = 237;
pub const SYS_membarrier: u32 = 324;
pub const SYS_memfd_create: u32 = 319;
pub const SYS_memfd_secret: u32 = 447;
pub const SYS_migrate_pages: u32 = 256;
pub const SYS_mincore: u32 = 27;
pub const SYS_mkdir: u32 = 83;
pub const SYS_mkdirat: u32 = 258;
pub const SYS_mknod: u32 = 133;
pub const SYS_mknodat: u32 = 259;
pub const SYS_mlock: u32 = 149;
pub const SYS_mlock2: u32 = 325;
pub const SYS_mlockall: u32 = 151;
pub const SYS_mmap: u32 = 9;
pub const SYS_modify_ldt: u32 = 154;
pub const SYS_mount: u32 = 165;
pub const SYS_mount_setattr: u32 = 442;
pub const SYS_move_mount: u32 = 429;
pub const SYS_move_pages: u32 = 279;
pub const SYS_mprotect: u32 = 10;
pub const SYS_mq_getsetattr: u32 = 245;
pub const SYS_mq_notify: u32 = 244;
pub const SYS_mq_open: u32 = 240;
pub const SYS_mq_timedreceive: u32 = 243;
pub const SYS_mq_timedsend: u32 = 242;
pub const SYS_mq_unlink: u32 = 241;
pub const SYS_mremap: u32 = 25;
pub const SYS_msgctl: u32 = 71;
pub const SYS_msgget: u32 = 68;
pub const SYS_msgrcv: u32 = 70;
pub const SYS_msgsnd: u32 = 69;
pub const SYS_msync: u32 = 26;
pub const SYS_munlock: u32 = 150;
pub const SYS_munlockall: u32 = 152;
pub const SYS_munmap: u32 = 11;
pub const SYS_name_to_handle_at: u32 = 303;
pub const SYS_nanosleep: u32 = 35;
pub const SYS_newfstatat: u32 = 262;
pub const SYS_nfsservctl: u32 = 180;
pub const SYS_open: u32 = 2;
pub const SYS_open_by_handle_at: u32 = 304;
pub const SYS_open_tree: u32 = 428;
pub const SYS_openat: u32 = 257;
pub const SYS_openat2: u32 = 437;
pub const SYS_pause: u32 = 34;
pub const SYS_perf_event_open: u32 = 298;
pub const SYS_personality: u32 = 135;
pub const SYS_pidfd_getfd: u32 = 438;
pub const SYS_pidfd_open: u32 = 434;
pub const SYS_pidfd_send_signal: u32 = 424;
pub const SYS_pipe: u32 = 22;
pub const SYS_pipe2: u32 = 293;
pub const SYS_pivot_root: u32 = 155;
pub const SYS_pkey_alloc: u32 = 330;
pub const SYS_pkey_free: u32 = 331;
pub const SYS_pkey_mprotect: u32 = 329;
pub const SYS_poll: u32 = 7;
pub const SYS_ppoll: u32 = 271;
pub const SYS_prctl: u32 = 157;
pub const SYS_pread64: u32 = 17;
pub const SYS_preadv: u32 = 295;
pub const SYS_preadv2: u32 = 327;
pub const SYS_prlimit64: u32 = 302;
pub const SYS_process_madvise: u32 = 440;
pub const SYS_process_mrelease: u32 = 448;
pub const SYS_process_vm_readv: u32 = 310;
pub const SYS_process_vm_writev: u32 = 311;
pub const SYS_pselect6: u32 = 270;
pub const SYS_ptrace: u32 = 101;
pub const SYS_putpmsg: u32 = 182;
pub const SYS_pwrite64: u32 = 18;
pub const SYS_pwritev: u32 = 296;
pub const SYS_pwritev2: u32 = 328;
pub const SYS_query_module: u32 = 178;
pub const SYS_quotactl: u32 = 179;
pub const SYS_quotactl_fd: u32 = 443;
pub const SYS_read: u32 = 0;
pub const SYS_readahead: u32 = 187;
pub const SYS_readlink: u32 = 89;
pub const SYS_readlinkat: u32 = 267;
pub const SYS_readv: u32 = 19;
pub const SYS_reboot: u32 = 169;
pub const SYS_recvfrom: u32 = 45;
pub const SYS_recvmmsg: u32 = 299;
pub const SYS_recvmsg: u32 = 47;
pub const SYS_remap_file_pages: u32 = 216;
pub const SYS_removexattr: u32 = 197;
pub const SYS_rename: u32 = 82;
pub const SYS_renameat: u32 = 264;
pub const SYS_renameat2: u32 = 316;
pub const SYS_request_key: u32 = 249;
pub const SYS_restart_syscall: u32 = 219;
pub const SYS_rmdir: u32 = 84;
pub const SYS_rseq: u32 = 334;
pub const SYS_rt_sigaction: u32 = 13;
pub const SYS_rt_sigpending: u32 = 127;
pub const SYS_rt_sigprocmask: u32 = 14;
pub const SYS_rt_sigqueueinfo: u32 = 129;
pub const SYS_rt_sigreturn: u32 = 15;
pub const SYS_rt_sigsuspend: u32 = 130;
pub const SYS_rt_sigtimedwait: u32 = 128;
pub const SYS_rt_tgsigqueueinfo: u32 = 297;
pub const SYS_sched_get_priority_max: u32 = 146;
pub const SYS_sched_get_priority_min: u32 = 147;
pub const SYS_sched_getaffinity: u32 = 204;
pub const SYS_sched_getattr: u32 = 315;
pub const SYS_sched_getparam: u32 = 143;
pub const SYS_sched_getscheduler: u32 = 145;
pub const SYS_sched_rr_get_interval: u32 = 148;
pub const SYS_sched_setaffinity: u32 = 203;
pub const SYS_sched_setattr: u32 = 314;
pub const SYS_sched_setparam: u32 = 142;
pub const SYS_sched_setscheduler: u32 = 144;
pub const SYS_sched_yield: u32 = 24;
pub const SYS_seccomp: u32 = 317;
pub const SYS_security: u32 = 185;
pub const SYS_select: u32 = 23;
pub const SYS_semctl: u32 = 66;
pub const SYS_semget: u32 = 64;
pub const SYS_semop: u32 = 65;
pub const SYS_semtimedop: u32 = 220;
pub const SYS_sendfile: u32 = 40;
pub const SYS_sendmmsg: u32 = 307;
pub const SYS_sendmsg: u32 = 46;
pub const SYS_sendto: u32 = 44;
pub const SYS_set_mempolicy: u32 = 238;
pub const SYS_set_mempolicy_home_node: u32 = 450;
pub const SYS_set_robust_list: u32 = 273;
pub const SYS_set_thread_area: u32 = 205;
pub const SYS_set_tid_address: u32 = 218;
pub const SYS_setdomainname: u32 = 171;
pub const SYS_setfsgid: u32 = 123;
pub const SYS_setfsuid: u32 = 122;
pub const SYS_setgid: u32 = 106;
pub const SYS_setgroups: u32 = 116;
pub const SYS_sethostname: u32 = 170;
pub const SYS_setitimer: u32 = 38;
pub const SYS_setns: u32 = 308;
pub const SYS_setpgid: u32 = 109;
pub const SYS_setpriority: u32 = 141;
pub const SYS_setregid: u32 = 114;
pub const SYS_setresgid: u32 = 119;
pub const SYS_setresuid: u32 = 117;
pub const SYS_setreuid: u32 = 113;
pub const SYS_setrlimit: u32 = 160;
pub const SYS_setsid: u32 = 112;
pub const SYS_setsockopt: u32 = 54;
pub const SYS_settimeofday: u32 = 164;
pub const SYS_setuid: u32 = 105;
pub const SYS_setxattr: u32 = 188;
pub const SYS_shmat: u32 = 30;
pub const SYS_shmctl: u32 = 31;
pub const SYS_shmdt: u32 = 67;
pub const SYS_shmget: u32 = 29;
pub const SYS_shutdown: u32 = 48;
pub const SYS_sigaltstack: u32 = 131;
pub const SYS_signalfd: u32 = 282;
pub const SYS_signalfd4: u32 = 289;
pub const SYS_socket: u32 = 41;
pub const SYS_socketpair: u32 = 53;
pub const SYS_splice: u32 = 275;
pub const SYS_stat: u32 = 4;
pub const SYS_statfs: u32 = 137;
pub const SYS_statx: u32 = 332;
pub const SYS_swapoff: u32 = 168;
pub const SYS_swapon: u32 = 167;
pub const SYS_symlink: u32 = 88;
pub const SYS_symlinkat: u32 = 266;
pub const SYS_sync: u32 = 162;
pub const SYS_sync_file_range: u32 = 277;
pub const SYS_syncfs: u32 = 306;
pub const SYS_sysfs: u32 = 139;
pub const SYS_sysinfo: u32 = 99;
pub const SYS_syslog: u32 = 103;
pub const SYS_tee: u32 = 276;
pub const SYS_tgkill: u32 = 234;
pub const SYS_time: u32 = 201;
pub const SYS_timer_create: u32 = 222;
pub const SYS_timer_delete: u32 = 226;
pub const SYS_timer_getoverrun: u32 = 225;
pub const SYS_timer_gettime: u32 = 224;
pub const SYS_timer_settime: u32 = 223;
pub const SYS_timerfd_create: u32 = 283;
pub const SYS_timerfd_gettime: u32 = 287;
pub const SYS_timerfd_settime: u32 = 286;
pub const SYS_times: u32 = 100;
pub const SYS_tkill: u32 = 200;
pub const SYS_truncate: u32 = 76;
pub const SYS_tuxcall: u32 = 184;
pub const SYS_umask: u32 = 95;
pub const SYS_umount2: u32 = 166;
pub const SYS_uname: u32 = 63;
pub const SYS_unlink: u32 = 87;
pub const SYS_unlinkat: u32 = 263;
pub const SYS_unshare: u32 = 272;
pub const SYS_uselib: u32 = 134;
pub const SYS_userfaultfd: u32 = 323;
pub const SYS_ustat: u32 = 136;
pub const SYS_utime: u32 = 132;
pub const SYS_utimensat: u32 = 280;
pub const SYS_utimes: u32 = 235;
pub const SYS_vfork: u32 = 58;
pub const SYS_vhangup: u32 = 153;
pub const SYS_vmsplice: u32 = 278;
pub const SYS_vserver: u32 = 236;
pub const SYS_wait4: u32 = 61;
pub const SYS_waitid: u32 = 247;
pub const SYS_write: u32 = 1;
pub const SYS_writev: u32 = 20;
pub const ATCA_SHA256_BLOCK_SIZE: u32 = 64;
pub const ATCA_SHA256_DIGEST_SIZE: u32 = 32;
pub const ATCA_SHA384_BLOCK_SIZE: u32 = 128;
pub const ATCA_SHA384_DIGEST_SIZE: u32 = 48;
pub const ATCA_SHA512_BLOCK_SIZE: u32 = 128;
pub const ATCA_SHA512_DIGEST_SIZE: u32 = 64;
pub const ATCA_AES128_BLOCK_SIZE: u32 = 16;
pub const ATCA_AES128_KEY_SIZE: u32 = 16;
pub const ATCA_AES256_BLOCK_SIZE: u32 = 16;
pub const ATCA_AES256_KEY_SIZE: u32 = 32;
pub const ATCA_ECCP256_KEY_SIZE: u32 = 32;
pub const ATCA_ECCP256_PUBKEY_SIZE: u32 = 64;
pub const ATCA_ECCP256_SIG_SIZE: u32 = 64;
pub const CALIB_SHA204_EN: u32 = 0;
pub const CALIB_SHA206_EN: u32 = 0;
pub const CALIB_ECC108_EN: u32 = 0;
pub const CALIB_ECC508_EN: u32 = 0;
pub const CALIB_ECC608_EN: u32 = 1;
pub const CALIB_ECC204_EN: u32 = 0;
pub const CALIB_TA010_EN: u32 = 0;
pub const CALIB_SHA104_EN: u32 = 0;
pub const CALIB_SHA105_EN: u32 = 0;
pub const DEFAULT_CA_MAX_PACKET_SIZE: u32 = 198;
pub const CA_MAX_PACKET_SIZE: u32 = 198;
pub const CALIB_INFO_LATCH_EN: u32 = 1;
pub const ATCAC_SHA1_EN: u32 = 1;
pub const ATCAC_SHA256_EN: u32 = 1;
pub const ATCAC_SHA256_HMAC_EN: u32 = 1;
pub const ATCAC_SHA256_HMAC_CTR_EN: u32 = 1;
pub const ATCAC_RANDOM_EN: u32 = 0;
pub const ATCAC_VERIFY_EN: u32 = 0;
pub const ATCAC_SIGN_EN: u32 = 0;
pub const ATCA_CRYPTO_SHA2_HMAC_CTR_EN: u32 = 1;
pub const ATCAC_PBKDF2_SHA256_EN: u32 = 1;
pub const ATCA_AES_ENABLE_EN_SHIFT: u32 = 0;
pub const ATCA_AES_ENABLE_EN_MASK: u32 = 1;
pub const ATCA_I2C_ENABLE_EN_SHIFT: u32 = 0;
pub const ATCA_I2C_ENABLE_EN_MASK: u32 = 1;
pub const ATCA_COUNTER_MATCH_EN_SHIFT: u32 = 0;
pub const ATCA_COUNTER_MATCH_EN_MASK: u32 = 1;
pub const ATCA_COUNTER_MATCH_KEY_SHIFT: u32 = 4;
pub const ATCA_COUNTER_MATCH_KEY_MASK: u32 = 240;
pub const ATCA_CHIP_MODE_I2C_EXTRA_SHIFT: u32 = 0;
pub const ATCA_CHIP_MODE_I2C_EXTRA_MASK: u32 = 1;
pub const ATCA_CHIP_MODE_TTL_EN_SHIFT: u32 = 1;
pub const ATCA_CHIP_MODE_TTL_EN_MASK: u32 = 2;
pub const ATCA_CHIP_MODE_WDG_LONG_SHIFT: u32 = 2;
pub const ATCA_CHIP_MODE_WDG_LONG_MASK: u32 = 4;
pub const ATCA_CHIP_MODE_CLK_DIV_SHIFT: u32 = 3;
pub const ATCA_CHIP_MODE_CLK_DIV_MASK: u32 = 248;
pub const ATCA_SLOT_CONFIG_READKEY_SHIFT: u32 = 0;
pub const ATCA_SLOT_CONFIG_READKEY_MASK: u32 = 15;
pub const ATCA_SLOT_CONFIG_NOMAC_SHIFT: u32 = 4;
pub const ATCA_SLOT_CONFIG_NOMAC_MASK: u32 = 16;
pub const ATCA_SLOT_CONFIG_LIMITED_USE_SHIFT: u32 = 5;
pub const ATCA_SLOT_CONFIG_LIMITED_USE_MASK: u32 = 32;
pub const ATCA_SLOT_CONFIG_ENC_READ_SHIFT: u32 = 6;
pub const ATCA_SLOT_CONFIG_ENC_READ_MASK: u32 = 64;
pub const ATCA_SLOT_CONFIG_IS_SECRET_SHIFT: u32 = 7;
pub const ATCA_SLOT_CONFIG_IS_SECRET_MASK: u32 = 128;
pub const ATCA_SLOT_CONFIG_WRITE_KEY_SHIFT: u32 = 8;
pub const ATCA_SLOT_CONFIG_WRITE_CONFIG_SHIFT: u32 = 12;
pub const ATCA_SLOT_CONFIG_EXT_SIG_SHIFT: u32 = 0;
pub const ATCA_SLOT_CONFIG_EXT_SIG_MASK: u32 = 1;
pub const ATCA_SLOT_CONFIG_INT_SIG_SHIFT: u32 = 1;
pub const ATCA_SLOT_CONFIG_INT_SIG_MASK: u32 = 2;
pub const ATCA_SLOT_CONFIG_ECDH_SHIFT: u32 = 2;
pub const ATCA_SLOT_CONFIG_ECDH_MASK: u32 = 4;
pub const ATCA_SLOT_CONFIG_WRITE_ECDH_SHIFT: u32 = 3;
pub const ATCA_SLOT_CONFIG_WRITE_ECDH_MASK: u32 = 8;
pub const ATCA_SLOT_CONFIG_GEN_KEY_SHIFT: u32 = 8;
pub const ATCA_SLOT_CONFIG_GEN_KEY_MASK: u32 = 256;
pub const ATCA_SLOT_CONFIG_PRIV_WRITE_SHIFT: u32 = 9;
pub const ATCA_SLOT_CONFIG_PRIV_WRITE_MASK: u32 = 512;
pub const ATCA_USE_LOCK_ENABLE_SHIFT: u32 = 0;
pub const ATCA_USE_LOCK_ENABLE_MASK: u32 = 15;
pub const ATCA_USE_LOCK_KEY_SHIFT: u32 = 4;
pub const ATCA_USE_LOCK_KEY_MASK: u32 = 240;
pub const ATCA_VOL_KEY_PERM_SLOT_SHIFT: u32 = 0;
pub const ATCA_VOL_KEY_PERM_SLOT_MASK: u32 = 15;
pub const ATCA_VOL_KEY_PERM_EN_SHIFT: u32 = 7;
pub const ATCA_VOL_KEY_PERM_EN_MASK: u32 = 128;
pub const ATCA_SECURE_BOOT_MODE_SHIFT: u32 = 0;
pub const ATCA_SECURE_BOOT_MODE_MASK: u32 = 3;
pub const ATCA_SECURE_BOOT_PERSIST_EN_SHIFT: u32 = 3;
pub const ATCA_SECURE_BOOT_PERSIST_EN_MASK: u32 = 8;
pub const ATCA_SECURE_BOOT_RAND_NONCE_SHIFT: u32 = 4;
pub const ATCA_SECURE_BOOT_RAND_NONCE_MASK: u32 = 16;
pub const ATCA_SECURE_BOOT_DIGEST_SHIFT: u32 = 8;
pub const ATCA_SECURE_BOOT_DIGEST_MASK: u32 = 3840;
pub const ATCA_SECURE_BOOT_PUB_KEY_SHIFT: u32 = 12;
pub const ATCA_SECURE_BOOT_PUB_KEY_MASK: u32 = 61440;
pub const ATCA_CHIP_OPT_POST_EN_SHIFT: u32 = 0;
pub const ATCA_CHIP_OPT_POST_EN_MASK: u32 = 1;
pub const ATCA_CHIP_OPT_IO_PROT_EN_SHIFT: u32 = 1;
pub const ATCA_CHIP_OPT_IO_PROT_EN_MASK: u32 = 2;
pub const ATCA_CHIP_OPT_KDF_AES_EN_SHIFT: u32 = 2;
pub const ATCA_CHIP_OPT_KDF_AES_EN_MASK: u32 = 4;
pub const ATCA_CHIP_OPT_ECDH_PROT_SHIFT: u32 = 8;
pub const ATCA_CHIP_OPT_ECDH_PROT_MASK: u32 = 768;
pub const ATCA_CHIP_OPT_KDF_PROT_SHIFT: u32 = 10;
pub const ATCA_CHIP_OPT_KDF_PROT_MASK: u32 = 3072;
pub const ATCA_CHIP_OPT_IO_PROT_KEY_SHIFT: u32 = 12;
pub const ATCA_KEY_CONFIG_PRIVATE_SHIFT: u32 = 0;
pub const ATCA_KEY_CONFIG_PRIVATE_MASK: u32 = 1;
pub const ATCA_KEY_CONFIG_PUB_INFO_SHIFT: u32 = 1;
pub const ATCA_KEY_CONFIG_PUB_INFO_MASK: u32 = 2;
pub const ATCA_KEY_CONFIG_KEY_TYPE_SHIFT: u32 = 2;
pub const ATCA_KEY_CONFIG_KEY_TYPE_MASK: u32 = 28;
pub const ATCA_KEY_CONFIG_LOCKABLE_SHIFT: u32 = 5;
pub const ATCA_KEY_CONFIG_LOCKABLE_MASK: u32 = 32;
pub const ATCA_KEY_CONFIG_REQ_RANDOM_SHIFT: u32 = 6;
pub const ATCA_KEY_CONFIG_REQ_RANDOM_MASK: u32 = 64;
pub const ATCA_KEY_CONFIG_REQ_AUTH_SHIFT: u32 = 7;
pub const ATCA_KEY_CONFIG_REQ_AUTH_MASK: u32 = 128;
pub const ATCA_KEY_CONFIG_AUTH_KEY_SHIFT: u32 = 8;
pub const ATCA_KEY_CONFIG_AUTH_KEY_MASK: u32 = 3840;
pub const ATCA_KEY_CONFIG_PERSIST_DIS_SHIFT: u32 = 12;
pub const ATCA_KEY_CONFIG_PERSIST_DIS_MASK: u32 = 4096;
pub const ATCA_KEY_CONFIG_RFU_SHIFT: u32 = 13;
pub const ATCA_KEY_CONFIG_RFU_MASK: u32 = 8192;
pub const ATCA_KEY_CONFIG_X509_ID_SHIFT: u32 = 14;
pub const ATCA_KEY_CONFIG_X509_ID_MASK: u32 = 49152;
pub const ATCA_CMD_SIZE_MIN: u32 = 7;
pub const ATCA_BLOCK_SIZE: u32 = 32;
pub const ATCA_WORD_SIZE: u32 = 4;
pub const ATCA_PUB_KEY_PAD: u32 = 4;
pub const ATCA_SERIAL_NUM_SIZE: u32 = 9;
pub const ATCA_KEY_COUNT: u32 = 16;
pub const ATCA_ECC_CONFIG_SIZE: u32 = 128;
pub const ATCA_SHA_CONFIG_SIZE: u32 = 88;
pub const ATCA_CA2_CONFIG_SIZE: u32 = 64;
pub const ATCA_CA2_CONFIG_SLOT_SIZE: u32 = 16;
pub const ATCA_OTP_SIZE: u32 = 64;
pub const ATCA_AES_GFM_SIZE: u32 = 32;
pub const ATCA_CHIPMODE_OFFSET: u32 = 19;
pub const ATCA_COUNT_SIZE: u32 = 1;
pub const ATCA_CRC_SIZE: u32 = 2;
pub const ATCA_PACKET_OVERHEAD: u32 = 3;
pub const ATCA_PUB_KEY_SIZE: u32 = 64;
pub const ATCA_PRIV_KEY_SIZE: u32 = 32;
pub const ATCA_SIG_SIZE: u32 = 64;
pub const ATCA_KEY_SIZE: u32 = 32;
pub const RSA2048_KEY_SIZE: u32 = 256;
pub const ATCA_RSP_SIZE_32: u32 = 35;
pub const OUTNONCE_SIZE: u32 = 32;
pub const ATCA_COUNT_IDX: u32 = 0;
pub const ATCA_OPCODE_IDX: u32 = 1;
pub const ATCA_PARAM1_IDX: u32 = 2;
pub const ATCA_PARAM2_IDX: u32 = 3;
pub const ATCA_DATA_IDX: u32 = 5;
pub const ATCA_RSP_DATA_IDX: u32 = 1;
pub const ATCA_B283_KEY_TYPE: u32 = 0;
pub const ATCA_K283_KEY_TYPE: u32 = 1;
pub const ATCA_P256_KEY_TYPE: u32 = 4;
pub const ATCA_AES_KEY_TYPE: u32 = 6;
pub const ATCA_SHA_KEY_TYPE: u32 = 7;
pub const AES_MODE_IDX: u32 = 2;
pub const AES_KEYID_IDX: u32 = 3;
pub const AES_INPUT_IDX: u32 = 5;
pub const AES_COUNT: u32 = 23;
pub const AES_MODE_KEY_BLOCK_POS: u32 = 6;
pub const AES_DATA_SIZE: u32 = 16;
pub const CHECKMAC_MODE_IDX: u32 = 2;
pub const CHECKMAC_KEYID_IDX: u32 = 3;
pub const CHECKMAC_CLIENT_CHALLENGE_IDX: u32 = 5;
pub const CHECKMAC_CLIENT_RESPONSE_IDX: u32 = 37;
pub const CHECKMAC_DATA_IDX: u32 = 69;
pub const CHECKMAC_COUNT: u32 = 84;
pub const CHECKMAC_CLIENT_CHALLENGE_SIZE: u32 = 32;
pub const CHECKMAC_CLIENT_RESPONSE_SIZE: u32 = 32;
pub const CHECKMAC_OTHER_DATA_SIZE: u32 = 13;
pub const CHECKMAC_CLIENT_COMMAND_SIZE: u32 = 4;
pub const CHECKMAC_CMD_MATCH: u32 = 0;
pub const CHECKMAC_CMD_MISMATCH: u32 = 1;
pub const CHECKMAC_SINGLE_BYTE_BOOL_RESP: u32 = 1;
pub const COUNTER_COUNT: u32 = 7;
pub const COUNTER_MODE_IDX: u32 = 2;
pub const COUNTER_KEYID_IDX: u32 = 3;
pub const DELETE_COUNT: u32 = 39;
pub const DELETE_MAC_SIZE: u32 = 32;
pub const DERIVE_KEY_RANDOM_IDX: u32 = 2;
pub const DERIVE_KEY_TARGETKEY_IDX: u32 = 3;
pub const DERIVE_KEY_MAC_IDX: u32 = 5;
pub const DERIVE_KEY_COUNT_SMALL: u32 = 7;
pub const DERIVE_KEY_COUNT_LARGE: u32 = 39;
pub const DERIVE_KEY_MAC_SIZE: u32 = 32;
pub const ECDH_COUNT: u32 = 71;
pub const ECDH_KEY_SIZE: u32 = 32;
pub const GENDIG_ZONE_IDX: u32 = 2;
pub const GENDIG_KEYID_IDX: u32 = 3;
pub const GENDIG_DATA_IDX: u32 = 5;
pub const GENDIG_COUNT: u32 = 7;
pub const GENKEY_MODE_IDX: u32 = 2;
pub const GENKEY_KEYID_IDX: u32 = 3;
pub const GENKEY_DATA_IDX: u32 = 5;
pub const GENKEY_COUNT: u32 = 7;
pub const GENKEY_COUNT_DATA: u32 = 10;
pub const GENKEY_OTHER_DATA_SIZE: u32 = 3;
pub const HMAC_MODE_IDX: u32 = 2;
pub const HMAC_KEYID_IDX: u32 = 3;
pub const HMAC_COUNT: u32 = 7;
pub const HMAC_DIGEST_SIZE: u32 = 32;
pub const HMAC_RSP_SIZE: u32 = 35;
pub const INFO_PARAM1_IDX: u32 = 2;
pub const INFO_PARAM2_IDX: u32 = 3;
pub const INFO_COUNT: u32 = 7;
pub const KDF_MODE_IDX: u32 = 2;
pub const KDF_KEYID_IDX: u32 = 3;
pub const KDF_DETAILS_IDX: u32 = 5;
pub const KDF_DETAILS_SIZE: u32 = 4;
pub const KDF_MESSAGE_IDX: u32 = 9;
pub const LOCK_ZONE_IDX: u32 = 2;
pub const LOCK_SUMMARY_IDX: u32 = 3;
pub const LOCK_COUNT: u32 = 7;
pub const MAC_MODE_IDX: u32 = 2;
pub const MAC_KEYID_IDX: u32 = 3;
pub const MAC_CHALLENGE_IDX: u32 = 5;
pub const MAC_COUNT_SHORT: u32 = 7;
pub const MAC_COUNT_LONG: u32 = 39;
pub const MAC_CHALLENGE_SIZE: u32 = 32;
pub const MAC_SIZE: u32 = 32;
pub const MAC_RSP_SIZE: u32 = 35;
pub const NONCE_MODE_IDX: u32 = 2;
pub const NONCE_PARAM2_IDX: u32 = 3;
pub const NONCE_INPUT_IDX: u32 = 5;
pub const NONCE_COUNT_SHORT: u32 = 27;
pub const NONCE_COUNT_LONG: u32 = 39;
pub const NONCE_COUNT_LONG_64: u32 = 71;
pub const NONCE_NUMIN_SIZE: u32 = 20;
pub const NONCE_NUMIN_SIZE_PASSTHROUGH: u32 = 32;
pub const NONCE_RSP_SIZE_LONG: u32 = 35;
pub const PAUSE_SELECT_IDX: u32 = 2;
pub const PAUSE_PARAM2_IDX: u32 = 3;
pub const PAUSE_COUNT: u32 = 7;
pub const PRIVWRITE_ZONE_IDX: u32 = 2;
pub const PRIVWRITE_KEYID_IDX: u32 = 3;
pub const PRIVWRITE_VALUE_IDX: u32 = 5;
pub const PRIVWRITE_MAC_IDX: u32 = 41;
pub const PRIVWRITE_COUNT: u32 = 75;
pub const RANDOM_MODE_IDX: u32 = 2;
pub const RANDOM_PARAM2_IDX: u32 = 3;
pub const RANDOM_COUNT: u32 = 7;
pub const RANDOM_RSP_SIZE: u32 = 35;
pub const READ_ZONE_IDX: u32 = 2;
pub const READ_ADDR_IDX: u32 = 3;
pub const READ_COUNT: u32 = 7;
pub const READ_32_RSP_SIZE: u32 = 35;
pub const SECUREBOOT_MODE_IDX: u32 = 2;
pub const SECUREBOOT_DIGEST_SIZE: u32 = 32;
pub const SECUREBOOT_SIGNATURE_SIZE: u32 = 64;
pub const SECUREBOOT_COUNT_DIG: u32 = 39;
pub const SECUREBOOT_COUNT_DIG_SIG: u32 = 103;
pub const SECUREBOOT_MAC_SIZE: u32 = 32;
pub const SECUREBOOT_RSP_SIZE_MAC: u32 = 35;
pub const SECUREBOOTCONFIG_OFFSET: u32 = 70;
pub const SELFTEST_MODE_IDX: u32 = 2;
pub const SELFTEST_COUNT: u32 = 7;
pub const SHA_COUNT_SHORT: u32 = 7;
pub const SHA_COUNT_LONG: u32 = 7;
pub const ATCA_SHA_DIGEST_SIZE: u32 = 32;
pub const SHA_DATA_MAX: u32 = 64;
pub const SHA_RSP_SIZE: u32 = 35;
pub const SHA_RSP_SIZE_LONG: u32 = 35;
pub const SIGN_MODE_IDX: u32 = 2;
pub const SIGN_KEYID_IDX: u32 = 3;
pub const SIGN_COUNT: u32 = 7;
pub const UPDATE_MODE_IDX: u32 = 2;
pub const UPDATE_VALUE_IDX: u32 = 3;
pub const UPDATE_COUNT: u32 = 7;
pub const VERIFY_MODE_IDX: u32 = 2;
pub const VERIFY_KEYID_IDX: u32 = 3;
pub const VERIFY_DATA_IDX: u32 = 5;
pub const VERIFY_256_STORED_COUNT: u32 = 71;
pub const VERIFY_283_STORED_COUNT: u32 = 79;
pub const VERIFY_256_VALIDATE_COUNT: u32 = 90;
pub const VERIFY_283_VALIDATE_COUNT: u32 = 98;
pub const VERIFY_256_EXTERNAL_COUNT: u32 = 135;
pub const VERIFY_283_EXTERNAL_COUNT: u32 = 151;
pub const VERIFY_256_KEY_SIZE: u32 = 64;
pub const VERIFY_283_KEY_SIZE: u32 = 72;
pub const VERIFY_256_SIGNATURE_SIZE: u32 = 64;
pub const VERIFY_283_SIGNATURE_SIZE: u32 = 72;
pub const VERIFY_OTHER_DATA_SIZE: u32 = 19;
pub const VERIFY_RSP_SIZE_MAC: u32 = 35;
pub const WRITE_ZONE_IDX: u32 = 2;
pub const WRITE_ADDR_IDX: u32 = 3;
pub const WRITE_VALUE_IDX: u32 = 5;
pub const WRITE_MAC_VS_IDX: u32 = 9;
pub const WRITE_MAC_VL_IDX: u32 = 37;
pub const WRITE_MAC_SIZE: u32 = 32;
pub const CALIB_SWI_FLAG_WAKE: u32 = 0;
pub const CALIB_SWI_FLAG_CMD: u32 = 119;
pub const CALIB_SWI_FLAG_TX: u32 = 136;
pub const CALIB_SWI_FLAG_IDLE: u32 = 187;
pub const CALIB_SWI_FLAG_SLEEP: u32 = 204;
pub const ATCA_AES_GCM_IV_STD_LENGTH: u32 = 12;
pub const ATCA_SHA1_DIGEST_SIZE: u32 = 20;
pub const ATCA_SHA2_256_DIGEST_SIZE: u32 = 32;
pub const ATCA_SHA2_256_BLOCK_SIZE: u32 = 64;
pub const SHA_CONTEXT_MAX_SIZE: u32 = 109;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::core::ffi::c_uint,
    pub __wchb: [::core::ffi::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::core::ffi::c_int,
    pub _IO_read_ptr: *mut ::core::ffi::c_char,
    pub _IO_read_end: *mut ::core::ffi::c_char,
    pub _IO_read_base: *mut ::core::ffi::c_char,
    pub _IO_write_base: *mut ::core::ffi::c_char,
    pub _IO_write_ptr: *mut ::core::ffi::c_char,
    pub _IO_write_end: *mut ::core::ffi::c_char,
    pub _IO_buf_base: *mut ::core::ffi::c_char,
    pub _IO_buf_end: *mut ::core::ffi::c_char,
    pub _IO_save_base: *mut ::core::ffi::c_char,
    pub _IO_backup_base: *mut ::core::ffi::c_char,
    pub _IO_save_end: *mut ::core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::core::ffi::c_int,
    pub _flags2: ::core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::core::ffi::c_ushort,
    pub _vtable_offset: ::core::ffi::c_schar,
    pub _shortbuf: [::core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::core::ffi::c_int,
    pub _unused2: [::core::ffi::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *mut ::core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *const ::core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __pos: *mut __off64_t,
        __w: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::core::ffi::c_char,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::core::ffi::c_int,
        __old: *const ::core::ffi::c_char,
        __newfd: ::core::ffi::c_int,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::core::ffi::c_char,
        __pfx: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::core::ffi::c_int, __modes: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::core::ffi::c_void,
        __modes: *const ::core::ffi::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::core::ffi::c_void,
        __len: usize,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::core::ffi::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::core::ffi::c_char,
        __modes: ::core::ffi::c_int,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __f: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::core::ffi::c_char,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(__w: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __s: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::core::ffi::c_long,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::core::ffi::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::core::ffi::c_uint,
    pub __high: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::core::ffi::c_int,
    pub __count: ::core::ffi::c_uint,
    pub __owner: ::core::ffi::c_int,
    pub __nusers: ::core::ffi::c_uint,
    pub __kind: ::core::ffi::c_int,
    pub __spins: ::core::ffi::c_short,
    pub __elision: ::core::ffi::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::core::ffi::c_uint,
    pub __writers: ::core::ffi::c_uint,
    pub __wrphase_futex: ::core::ffi::c_uint,
    pub __writers_futex: ::core::ffi::c_uint,
    pub __pad3: ::core::ffi::c_uint,
    pub __pad4: ::core::ffi::c_uint,
    pub __cur_writer: ::core::ffi::c_int,
    pub __shared: ::core::ffi::c_int,
    pub __rwelision: ::core::ffi::c_schar,
    pub __pad1: [::core::ffi::c_uchar; 7usize],
    pub __pad2: ::core::ffi::c_ulong,
    pub __flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::core::ffi::c_uint; 2usize],
    pub __g_size: [::core::ffi::c_uint; 2usize],
    pub __g1_orig_size: ::core::ffi::c_uint,
    pub __wrefs: ::core::ffi::c_uint,
    pub __g_signals: [::core::ffi::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::core::ffi::c_uint;
pub type __thrd_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::core::ffi::c_uint;
pub type pthread_once_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::core::ffi::c_char; 40usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::core::ffi::c_char; 48usize],
    pub __align: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::core::ffi::c_char; 8usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::core::ffi::c_char; 32usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::core::ffi::c_int,
    pub rand_deg: ::core::ffi::c_int,
    pub rand_sep: ::core::ffi::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::core::ffi::c_uint, __buf: *mut random_data) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::core::ffi::c_char,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::core::ffi::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::core::ffi::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::core::ffi::c_ushort; 3usize],
    pub __old_x: [::core::ffi::c_ushort; 3usize],
    pub __c: ::core::ffi::c_ushort,
    pub __init: ::core::ffi::c_ushort,
    pub __a: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::core::ffi::c_long,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::core::ffi::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn alloca(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::core::ffi::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: ::core::ffi::c_int, __arg: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __replace: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearenv() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::core::ffi::c_char,
        __suffixlen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn system(__command: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::core::ffi::c_char,
        __resolved: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(__x: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llabs(__x: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::core::ffi::c_char, __n: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::core::ffi::c_char,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::core::ffi::c_char, __wchar: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::core::ffi::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::core::ffi::c_char,
        __tokens: *const *mut ::core::ffi::c_char,
        __valuep: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const ::core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn hal_malloc(size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn hal_free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn lib_strcasestr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
pub type ATCA_STATUS = ::core::ffi::c_int;
extern "C" {
    pub fn atca_trace(status: ATCA_STATUS) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cal_buffer_s {
    #[doc = " Length of the provided buffer"]
    pub len: usize,
    #[doc = " Pointer to the actual buffer"]
    pub buf: *mut u8,
}
#[test]
fn bindgen_test_layout_cal_buffer_s() {
    const UNINIT: ::core::mem::MaybeUninit<cal_buffer_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cal_buffer_s>(),
        16usize,
        concat!("Size of: ", stringify!(cal_buffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cal_buffer_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cal_buffer_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cal_buffer_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cal_buffer_s),
            "::",
            stringify!(buf)
        )
    );
}
pub type cal_buffer = cal_buffer_s;
extern "C" {
    pub fn cal_buf_read_byte(cab: *mut cal_buffer, offset: usize, value: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_write_byte(cab: *mut cal_buffer, offset: usize, value: u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_read_bytes(
        cab: *mut cal_buffer,
        offset: usize,
        dest: *mut ::core::ffi::c_void,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_write_bytes(
        cab: *mut cal_buffer,
        offset: usize,
        source: *const ::core::ffi::c_void,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_read_number(
        cab: *mut cal_buffer,
        offset: usize,
        dest: *mut ::core::ffi::c_void,
        num_size: usize,
        buf_big_endian: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_write_number(
        cab: *mut cal_buffer,
        offset: usize,
        source: *const ::core::ffi::c_void,
        num_size: usize,
        buf_big_endian: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_copy(
        dst: *mut cal_buffer,
        dst_offset: usize,
        src: *mut cal_buffer,
        src_offset: usize,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_set(
        dst: *mut cal_buffer,
        dst_offset: usize,
        value: u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_set_used(buf: *mut cal_buffer, used: usize) -> ATCA_STATUS;
}
extern "C" {
    pub fn cal_buf_get_used(buf: *mut cal_buffer) -> usize;
}
pub type ATCADeviceType = u8;
#[doc = "< Native I2C Driver"]
pub const ATCAIfaceType_ATCA_I2C_IFACE: ATCAIfaceType = 0;
#[doc = "< SWI or 1-Wire over UART/USART"]
pub const ATCAIfaceType_ATCA_SWI_IFACE: ATCAIfaceType = 1;
#[doc = "< Kit v1 over UART/USART"]
pub const ATCAIfaceType_ATCA_UART_IFACE: ATCAIfaceType = 2;
#[doc = "< Native SPI Driver"]
pub const ATCAIfaceType_ATCA_SPI_IFACE: ATCAIfaceType = 3;
#[doc = "< Kit v1 over HID"]
pub const ATCAIfaceType_ATCA_HID_IFACE: ATCAIfaceType = 4;
#[doc = "< Kit v2 (Binary/Bridging)"]
pub const ATCAIfaceType_ATCA_KIT_IFACE: ATCAIfaceType = 5;
#[doc = "< Custom HAL functions provided during interface init"]
pub const ATCAIfaceType_ATCA_CUSTOM_IFACE: ATCAIfaceType = 6;
#[doc = "< I2C \"Bitbang\" Driver"]
pub const ATCAIfaceType_ATCA_I2C_GPIO_IFACE: ATCAIfaceType = 7;
#[doc = "< SWI or 1-Wire using a GPIO"]
pub const ATCAIfaceType_ATCA_SWI_GPIO_IFACE: ATCAIfaceType = 8;
#[doc = "< SWI or 1-Wire using a GPIO"]
pub const ATCAIfaceType_ATCA_SPI_GPIO_IFACE: ATCAIfaceType = 9;
pub const ATCAIfaceType_ATCA_UNKNOWN_IFACE: ATCAIfaceType = 254;
pub type ATCAIfaceType = ::core::ffi::c_uchar;
pub const ATCAKitType_ATCA_KIT_AUTO_IFACE: ATCAKitType = 0;
pub const ATCAKitType_ATCA_KIT_I2C_IFACE: ATCAKitType = 1;
pub const ATCAKitType_ATCA_KIT_SWI_IFACE: ATCAKitType = 2;
pub const ATCAKitType_ATCA_KIT_SPI_IFACE: ATCAKitType = 3;
pub const ATCAKitType_ATCA_KIT_UNKNOWN_IFACE: ATCAKitType = 4;
pub type ATCAKitType = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ATCAIfaceCfg {
    pub iface_type: ATCAIfaceType,
    pub devtype: ATCADeviceType,
    pub __bindgen_anon_1: ATCAIfaceCfg__bindgen_ty_1,
    pub wake_delay: u16,
    pub rx_retries: ::core::ffi::c_int,
    pub cfg_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ATCAIfaceCfg__bindgen_ty_1 {
    pub atcai2c: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1,
    pub atcaswi: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2,
    pub atcaspi: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3,
    pub atcauart: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4,
    pub atcahid: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5,
    pub atcakit: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6,
    pub atcacustom: ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Device address - the upper 7 bits are the I2c address bits"]
    pub address: u8,
    pub bus: u8,
    pub baud: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baud) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(baud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2 {
    pub address: u8,
    pub bus: u8,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3 {
    pub bus: u8,
    pub select_pin: u8,
    pub baud: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).select_pin) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(select_pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baud) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(baud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4 {
    pub dev_interface: ATCAKitType,
    pub dev_identity: u8,
    pub port: u8,
    pub baud: u32,
    pub wordsize: u8,
    pub parity: u8,
    pub stopbits: u8,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(dev_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_identity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(dev_identity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baud) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(baud)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wordsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(wordsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parity) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stopbits) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(stopbits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5 {
    pub idx: ::core::ffi::c_int,
    pub dev_interface: ATCAKitType,
    pub dev_identity: u8,
    pub vid: u32,
    pub pid: u32,
    pub packetsize: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(dev_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_identity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(dev_identity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(vid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packetsize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(packetsize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6 {
    pub dev_interface: ATCAKitType,
    pub dev_identity: u8,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(dev_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_identity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(dev_identity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7 {
    pub halinit: ::core::option::Option<
        unsafe extern "C" fn(
            hal: *mut ::core::ffi::c_void,
            cfg: *mut ::core::ffi::c_void,
        ) -> ATCA_STATUS,
    >,
    pub halpostinit: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halsend: ::core::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::core::ffi::c_void,
            word_address: u8,
            txdata: *mut u8,
            txlength: ::core::ffi::c_int,
        ) -> ATCA_STATUS,
    >,
    pub halreceive: ::core::option::Option<
        unsafe extern "C" fn(
            iface: *mut ::core::ffi::c_void,
            word_address: u8,
            rxdata: *mut u8,
            rxlength: *mut u16,
        ) -> ATCA_STATUS,
    >,
    pub halwake: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halidle: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halsleep: ::core::option::Option<
        unsafe extern "C" fn(iface: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
    pub halrelease: ::core::option::Option<
        unsafe extern "C" fn(hal_data: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halinit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halpostinit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halpostinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halsend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halsend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halreceive) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halreceive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halwake) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halwake)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halidle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halidle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halsleep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halsleep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halrelease) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(halrelease)
        )
    );
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(ATCAIfaceCfg__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAIfaceCfg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcai2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcai2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcaswi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcaswi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcaspi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcaspi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcauart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcauart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcahid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcahid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcakit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcakit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atcacustom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg__bindgen_ty_1),
            "::",
            stringify!(atcacustom)
        )
    );
}
#[test]
fn bindgen_test_layout_ATCAIfaceCfg() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAIfaceCfg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAIfaceCfg>(),
        88usize,
        concat!("Size of: ", stringify!(ATCAIfaceCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAIfaceCfg>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAIfaceCfg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iface_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(iface_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devtype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(devtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wake_delay) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(wake_delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_retries) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(rx_retries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfg_data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAIfaceCfg),
            "::",
            stringify!(cfg_data)
        )
    );
}
pub type ATCAIface = *mut atca_iface;
#[doc = " \\brief HAL Driver Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAHAL_t {
    pub halinit: ::core::option::Option<
        unsafe extern "C" fn(iface: ATCAIface, cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS,
    >,
    pub halpostinit: ::core::option::Option<unsafe extern "C" fn(iface: ATCAIface) -> ATCA_STATUS>,
    pub halsend: ::core::option::Option<
        unsafe extern "C" fn(
            iface: ATCAIface,
            word_address: u8,
            txdata: *mut u8,
            txlength: ::core::ffi::c_int,
        ) -> ATCA_STATUS,
    >,
    pub halreceive: ::core::option::Option<
        unsafe extern "C" fn(
            iface: ATCAIface,
            word_address: u8,
            rxdata: *mut u8,
            rxlength: *mut u16,
        ) -> ATCA_STATUS,
    >,
    pub halcontrol: ::core::option::Option<
        unsafe extern "C" fn(
            iface: ATCAIface,
            option: u8,
            param: *mut ::core::ffi::c_void,
            paramlen: usize,
        ) -> ATCA_STATUS,
    >,
    pub halrelease: ::core::option::Option<
        unsafe extern "C" fn(hal_data: *mut ::core::ffi::c_void) -> ATCA_STATUS,
    >,
}
#[test]
fn bindgen_test_layout_ATCAHAL_t() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAHAL_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAHAL_t>(),
        48usize,
        concat!("Size of: ", stringify!(ATCAHAL_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAHAL_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ATCAHAL_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halinit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halpostinit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halpostinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halsend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halsend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halreceive) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halreceive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halcontrol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halcontrol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halrelease) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAHAL_t),
            "::",
            stringify!(halrelease)
        )
    );
}
#[doc = " \\brief atca_iface is the context structure for a configured interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_iface {
    #[doc = "< Points to previous defined/given Cfg object, the caller manages this"]
    pub mIfaceCFG: *mut ATCAIfaceCfg,
    #[doc = "< The configured HAL for the interface"]
    pub hal: *mut ATCAHAL_t,
    #[doc = "< When a HAL is not a \"native\" hal it needs a physical layer to be associated with it"]
    pub phy: *mut ATCAHAL_t,
    #[doc = "< Pointer to HAL specific context/data"]
    pub hal_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_atca_iface() {
    const UNINIT: ::core::mem::MaybeUninit<atca_iface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_iface>(),
        32usize,
        concat!("Size of: ", stringify!(atca_iface))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_iface>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_iface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mIfaceCFG) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(mIfaceCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(hal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hal_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_iface),
            "::",
            stringify!(hal_data)
        )
    );
}
#[doc = " \\brief atca_iface is the context structure for a configured interface"]
pub type atca_iface_t = atca_iface;
extern "C" {
    pub fn initATCAIface(cfg: *mut ATCAIfaceCfg, ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn releaseATCAIface(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn deleteATCAIface(ca_iface: *mut ATCAIface);
}
extern "C" {
    pub fn atinit(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atsend(
        ca_iface: ATCAIface,
        word_address: u8,
        txdata: *mut u8,
        txlength: ::core::ffi::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atreceive(
        ca_iface: ATCAIface,
        word_address: u8,
        rxdata: *mut u8,
        rxlength: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcontrol(
        ca_iface: ATCAIface,
        option: u8,
        param: *mut ::core::ffi::c_void,
        paramlen: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atwake(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atidle(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atsleep(ca_iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn atgetifacecfg(ca_iface: ATCAIface) -> *mut ATCAIfaceCfg;
}
extern "C" {
    pub fn atgetifacehaldat(ca_iface: ATCAIface) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn ifacecfg_set_address(
        cfg: *mut ATCAIfaceCfg,
        address: u8,
        kitiface: ATCAKitType,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn ifacecfg_get_address(cfg: *mut ATCAIfaceCfg) -> u8;
}
extern "C" {
    pub fn ifacetype_is_kit(iface_type: ATCAIfaceType) -> bool;
}
extern "C" {
    pub fn atca_iface_is_kit(ca_iface: ATCAIface) -> bool;
}
extern "C" {
    pub fn atca_iface_is_swi(ca_iface: ATCAIface) -> bool;
}
extern "C" {
    pub fn atca_iface_get_retries(ca_iface: ATCAIface) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atca_iface_get_wake_delay(ca_iface: ATCAIface) -> u16;
}
extern "C" {
    pub fn iface_get_device_type_by_name(name: *const ::core::ffi::c_char) -> ATCADeviceType;
}
pub const ATCADeviceState_ATCA_DEVICE_STATE_UNKNOWN: ATCADeviceState = 0;
pub const ATCADeviceState_ATCA_DEVICE_STATE_SLEEP: ATCADeviceState = 1;
pub const ATCADeviceState_ATCA_DEVICE_STATE_IDLE: ATCADeviceState = 2;
pub const ATCADeviceState_ATCA_DEVICE_STATE_ACTIVE: ATCADeviceState = 3;
#[doc = " \\brief ATCADeviceState says about device state"]
pub type ATCADeviceState = ::core::ffi::c_uint;
#[doc = " \\brief Callback function to clean up the session context"]
pub type ctx_cb = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void)>;
#[doc = " \\brief atca_device is the C object backing ATCADevice.  See the atca_device.h file for\n details on the ATCADevice methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_device {
    #[doc = "< Physical interface"]
    pub mIface: atca_iface_t,
    #[doc = "< Device Power State"]
    pub device_state: u8,
    pub clock_divider: u8,
    pub execution_time_msec: u16,
    pub session_ctx: *mut ::core::ffi::c_void,
    pub session_cb: ctx_cb,
}
#[test]
fn bindgen_test_layout_atca_device() {
    const UNINIT: ::core::mem::MaybeUninit<atca_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_device>(),
        56usize,
        concat!("Size of: ", stringify!(atca_device))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_device>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mIface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(mIface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(device_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock_divider) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(clock_divider)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execution_time_msec) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(execution_time_msec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_ctx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(session_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).session_cb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_device),
            "::",
            stringify!(session_cb)
        )
    );
}
pub type ATCADevice = *mut atca_device;
extern "C" {
    pub fn initATCADevice(cfg: *mut ATCAIfaceCfg, ca_dev: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn newATCADevice(cfg: *mut ATCAIfaceCfg) -> ATCADevice;
}
extern "C" {
    pub fn releaseATCADevice(ca_dev: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn deleteATCADevice(ca_dev: *mut ATCADevice);
}
extern "C" {
    pub fn atGetIFace(dev: ATCADevice) -> ATCAIface;
}
extern "C" {
    pub fn atcab_bin2hex(
        bin: *const u8,
        bin_size: usize,
        hex: *mut ::core::ffi::c_char,
        hex_size: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_bin2hex_(
        bin: *const u8,
        bin_size: usize,
        hex: *mut ::core::ffi::c_char,
        hex_size: *mut usize,
        is_pretty: bool,
        is_space: bool,
        is_upper: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hex2bin(
        ascii_hex: *const ::core::ffi::c_char,
        ascii_hex_len: usize,
        binary: *mut u8,
        bin_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hex2bin_(
        hex: *const ::core::ffi::c_char,
        hex_size: usize,
        bin: *mut u8,
        bin_size: *mut usize,
        is_space: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn packHex(
        ascii_hex: *const ::core::ffi::c_char,
        ascii_hex_len: usize,
        packed_hex: *mut ::core::ffi::c_char,
        packed_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn isDigit(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isBlankSpace(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isAlpha(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isHexAlpha(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isHex(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isHexDigit(c: ::core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn isBase64(c: ::core::ffi::c_char, rules: *const u8) -> bool;
}
extern "C" {
    pub fn isBase64Digit(c: ::core::ffi::c_char, rules: *const u8) -> bool;
}
extern "C" {
    pub fn atcab_b64rules_default() -> *const u8;
}
extern "C" {
    pub fn atcab_b64rules_mime() -> *const u8;
}
extern "C" {
    pub fn atcab_b64rules_urlsafe() -> *const u8;
}
extern "C" {
    pub fn atcab_base64decode_(
        encoded: *const ::core::ffi::c_char,
        encoded_size: usize,
        data: *mut u8,
        data_size: *mut usize,
        rules: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64encode(
        byte_array: *const u8,
        array_len: usize,
        encoded: *mut ::core::ffi::c_char,
        encoded_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64encode_(
        data: *const u8,
        data_size: usize,
        encoded: *mut ::core::ffi::c_char,
        encoded_size: *mut usize,
        rules: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_base64decode(
        encoded: *const ::core::ffi::c_char,
        encoded_len: usize,
        byte_array: *mut u8,
        array_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_reversal(
        bin: *const u8,
        bin_size: usize,
        dest: *mut u8,
        dest_size: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_memset_s(
        dest: *mut ::core::ffi::c_void,
        destsz: usize,
        ch: ::core::ffi::c_int,
        count: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atcab_pointer_delta(
        start: *const ::core::ffi::c_void,
        end: *const ::core::ffi::c_void,
    ) -> usize;
}
extern "C" {
    pub fn lib_toupper(c: ::core::ffi::c_char) -> ::core::ffi::c_char;
}
extern "C" {
    pub fn lib_tolower(c: ::core::ffi::c_char) -> ::core::ffi::c_char;
}
#[doc = " \\defgroup hal_ Hardware abstraction layer (hal_)\n\n \\brief\n These methods define the hardware abstraction layer for communicating with a CryptoAuth device\n\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_hal_kit_phy_t {
    #[doc = "< Must be a blocking send"]
    pub send: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            txdata: *mut u8,
            txlen: u16,
        ) -> ATCA_STATUS,
    >,
    #[doc = "< Must be a blocking receive"]
    pub recv: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::core::ffi::c_void,
            rxdata: *mut u8,
            rxlen: *mut u16,
        ) -> ATCA_STATUS,
    >,
    #[doc = "< Allocate a phy packet"]
    pub packet_alloc:
        ::core::option::Option<unsafe extern "C" fn(bytes: usize) -> *mut ::core::ffi::c_void>,
    #[doc = "< Free a phy packet"]
    pub packet_free: ::core::option::Option<unsafe extern "C" fn(packet: *mut ::core::ffi::c_void)>,
    #[doc = "< Physical layer context"]
    pub hal_data: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_atca_hal_kit_phy_t() {
    const UNINIT: ::core::mem::MaybeUninit<atca_hal_kit_phy_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_hal_kit_phy_t>(),
        40usize,
        concat!("Size of: ", stringify!(atca_hal_kit_phy_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_hal_kit_phy_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_hal_kit_phy_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_kit_phy_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_kit_phy_t),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_alloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_kit_phy_t),
            "::",
            stringify!(packet_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).packet_free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_kit_phy_t),
            "::",
            stringify!(packet_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_kit_phy_t),
            "::",
            stringify!(hal_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_hal_shm_t {
    pub recordedPID: ::core::ffi::c_int,
    pub sessionID: u8,
    pub index: u8,
}
#[test]
fn bindgen_test_layout_atca_hal_shm_t() {
    const UNINIT: ::core::mem::MaybeUninit<atca_hal_shm_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_hal_shm_t>(),
        8usize,
        concat!("Size of: ", stringify!(atca_hal_shm_t))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_hal_shm_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_hal_shm_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recordedPID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_shm_t),
            "::",
            stringify!(recordedPID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sessionID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_shm_t),
            "::",
            stringify!(sessionID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_hal_shm_t),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn hal_iface_init(
        cfg: *mut ATCAIfaceCfg,
        hal: *mut *mut ATCAHAL_t,
        phy: *mut *mut ATCAHAL_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_iface_release(
        iface_type: ATCAIfaceType,
        hal_data: *mut ::core::ffi::c_void,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_check_wake(response: *const u8, response_size: ::core::ffi::c_int) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_init(iface: ATCAIface, cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_post_init(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_send(
        iface: ATCAIface,
        word_address: u8,
        txdata: *mut u8,
        txlength: ::core::ffi::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_receive(
        iface: ATCAIface,
        word_address: u8,
        rxdata: *mut u8,
        rxlength: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_control(
        iface: ATCAIface,
        option: u8,
        param: *mut ::core::ffi::c_void,
        paramlen: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_swi_release(hal_data: *mut ::core::ffi::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_init(iface: ATCAIface, cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_post_init(iface: ATCAIface) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_send(
        iface: ATCAIface,
        word_address: u8,
        txdata: *mut u8,
        txlength: ::core::ffi::c_int,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_receive(
        iface: ATCAIface,
        word_address: u8,
        rxdata: *mut u8,
        rxlength: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_control(
        iface: ATCAIface,
        option: u8,
        param: *mut ::core::ffi::c_void,
        paramlen: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_uart_release(hal_data: *mut ::core::ffi::c_void) -> ATCA_STATUS;
}
extern "C" {
    #[doc = " \\brief Timer API implemented at the HAL level"]
    pub fn hal_delay_ms(delay: u32);
}
extern "C" {
    pub fn hal_delay_us(delay: u32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::core::ffi::c_char; 32usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    const UNINIT: ::core::mem::MaybeUninit<sem_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::core::ffi::c_int,
        __value: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_open(
        __name: *const ::core::ffi::c_char,
        __oflag: ::core::ffi::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type hal_mutex_t = sem_t;
extern "C" {
    #[doc = " \\brief Optional hal interfaces"]
    pub fn hal_create_mutex(
        ppMutex: *mut *mut ::core::ffi::c_void,
        pName: *const ::core::ffi::c_char,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_init_mutex(pMutex: *mut ::core::ffi::c_void, shared: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_destroy_mutex(pMutex: *mut ::core::ffi::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_lock_mutex(pMutex: *mut ::core::ffi::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_unlock_mutex(pMutex: *mut ::core::ffi::c_void) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_alloc_shared(
        pShared: *mut *mut ::core::ffi::c_void,
        size: usize,
        pName: *const ::core::ffi::c_char,
        initialized: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_free_shared(pShared: *mut ::core::ffi::c_void, size: usize) -> ATCA_STATUS;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::core::ffi::c_char,
        __type: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::core::ffi::c_int,
        __file: *const ::core::ffi::c_char,
        __type: ::core::ffi::c_int,
        __flag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::core::ffi::c_int,
        __offset: __off_t,
        __whence: ::core::ffi::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::core::ffi::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(__fd: ::core::ffi::c_int, __buf: *const ::core::ffi::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::core::ffi::c_int,
        __buf: *const ::core::ffi::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pause() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::core::ffi::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::core::ffi::c_int,
        __file: *const ::core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::core::ffi::c_char, __size: usize) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn dup(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::core::ffi::c_int, __fd2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
        __envp: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::core::ffi::c_int,
        __argv: *const *mut ::core::ffi::c_char,
        __envp: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::core::ffi::c_char,
        __arg: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::core::ffi::c_char,
        __arg: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::core::ffi::c_char,
        __argv: *const *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::core::ffi::c_char,
        __arg: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nice(__inc: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _exit(__status: ::core::ffi::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::core::ffi::c_char,
        __name: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::core::ffi::c_int, __name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::core::ffi::c_int, __list: *mut __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::core::ffi::c_char,
        __to: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::core::ffi::c_int,
        __from: *const ::core::ffi::c_char,
        __tofd: ::core::ffi::c_int,
        __to: *const ::core::ffi::c_char,
        __flags: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::core::ffi::c_char,
        __to: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::core::ffi::c_char,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::core::ffi::c_char,
        __tofd: ::core::ffi::c_int,
        __to: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::core::ffi::c_int,
        __path: *const ::core::ffi::c_char,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::core::ffi::c_int,
        __name: *const ::core::ffi::c_char,
        __flag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::core::ffi::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::core::ffi::c_int, __pgrp_id: __pid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::core::ffi::c_char, __name_len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut optind: ::core::ffi::c_int;
}
extern "C" {
    pub static mut opterr: ::core::ffi::c_int;
}
extern "C" {
    pub static mut optopt: ::core::ffi::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::core::ffi::c_int,
        ___argv: *const *mut ::core::ffi::c_char,
        __shortopts: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vhangup() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::core::ffi::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::core::ffi::c_int,
        __noclose: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gethostid() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn truncate(__file: *const ::core::ffi::c_char, __length: __off_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::core::ffi::c_int, __length: __off_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::core::ffi::c_long, ...) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::core::ffi::c_int,
        __cmd: ::core::ffi::c_int,
        __len: __off_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::core::ffi::c_char,
        __salt: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getentropy(__buffer: *mut ::core::ffi::c_void, __length: usize) -> ::core::ffi::c_int;
}
pub type hal_pid_t = pid_t;
extern "C" {
    pub fn hal_check_pid(pid: hal_pid_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_iface_register_hal(
        iface_type: ATCAIfaceType,
        hal: *mut ATCAHAL_t,
        old_hal: *mut *mut ATCAHAL_t,
        phy: *mut ATCAHAL_t,
        old_phy: *mut *mut ATCAHAL_t,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn hal_is_command_word(word_address: u8) -> u8;
}
extern "C" {
    #[doc = " \\brief default configuration for an ECCx08A device on the logical SWI bus over UART"]
    pub static mut cfg_ateccx08a_swi_default: ATCAIfaceCfg;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct atsha204a_config_s {
    pub SN03: u32,
    pub RevNum: u32,
    pub SN47: u32,
    pub SN8: u8,
    pub Reserved0: u8,
    pub I2C_Enable: u8,
    pub Reserved1: u8,
    pub I2C_Address: u8,
    pub Reserved2: u8,
    pub OTPmode: u8,
    pub ChipMode: u8,
    pub SlotConfig: [u16; 16usize],
    pub Counter: [u16; 8usize],
    pub LastKeyUse: [u8; 16usize],
    pub UserExtra: u8,
    pub Selector: u8,
    pub LockValue: u8,
    pub LockConfig: u8,
}
#[test]
fn bindgen_test_layout_atsha204a_config_s() {
    const UNINIT: ::core::mem::MaybeUninit<atsha204a_config_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atsha204a_config_s>(),
        88usize,
        concat!("Size of: ", stringify!(atsha204a_config_s))
    );
    assert_eq!(
        ::core::mem::align_of::<atsha204a_config_s>(),
        1usize,
        concat!("Alignment of ", stringify!(atsha204a_config_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN03) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(SN03)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RevNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(RevNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN47) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(SN47)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN8) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(SN8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(Reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Enable) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(I2C_Enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(I2C_Address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTPmode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(OTPmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChipMode) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(ChipMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotConfig) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(SlotConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(Counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastKeyUse) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(LastKeyUse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserExtra) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(UserExtra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Selector) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(Selector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockValue) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(LockValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockConfig) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(atsha204a_config_s),
            "::",
            stringify!(LockConfig)
        )
    );
}
pub type atsha204a_config_t = atsha204a_config_s;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct atecc508a_config_s {
    pub SN03: u32,
    pub RevNum: u32,
    pub SN47: u32,
    pub SN8: u8,
    pub Reserved0: u8,
    pub I2C_Enable: u8,
    pub Reserved1: u8,
    pub I2C_Address: u8,
    pub Reserved2: u8,
    pub OTPmode: u8,
    pub ChipMode: u8,
    pub SlotConfig: [u16; 16usize],
    pub Counter0: [u8; 8usize],
    pub Counter1: [u8; 8usize],
    pub LastKeyUse: [u8; 16usize],
    pub UserExtra: u8,
    pub Selector: u8,
    pub LockValue: u8,
    pub LockConfig: u8,
    pub SlotLocked: u16,
    pub RFU: u16,
    pub X509format: u32,
    pub KeyConfig: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_atecc508a_config_s() {
    const UNINIT: ::core::mem::MaybeUninit<atecc508a_config_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atecc508a_config_s>(),
        128usize,
        concat!("Size of: ", stringify!(atecc508a_config_s))
    );
    assert_eq!(
        ::core::mem::align_of::<atecc508a_config_s>(),
        1usize,
        concat!("Alignment of ", stringify!(atecc508a_config_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN03) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(SN03)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RevNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(RevNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN47) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(SN47)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN8) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(SN8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved0) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Reserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Enable) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(I2C_Enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(I2C_Address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTPmode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(OTPmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChipMode) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(ChipMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotConfig) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(SlotConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter0) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Counter0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Counter1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastKeyUse) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(LastKeyUse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserExtra) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(UserExtra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Selector) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(Selector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockValue) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(LockValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockConfig) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(LockConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotLocked) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(SlotLocked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RFU) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(RFU)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).X509format) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(X509format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KeyConfig) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc508a_config_s),
            "::",
            stringify!(KeyConfig)
        )
    );
}
pub type atecc508a_config_t = atecc508a_config_s;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct atecc608_config_s {
    pub SN03: u32,
    pub RevNum: u32,
    pub SN47: u32,
    pub SN8: u8,
    pub AES_Enable: u8,
    pub I2C_Enable: u8,
    pub Reserved1: u8,
    pub I2C_Address: u8,
    pub Reserved2: u8,
    pub CountMatch: u8,
    pub ChipMode: u8,
    pub SlotConfig: [u16; 16usize],
    pub Counter0: [u8; 8usize],
    pub Counter1: [u8; 8usize],
    pub UseLock: u8,
    pub VolatileKeyPermission: u8,
    pub SecureBoot: u16,
    pub KdflvLoc: u8,
    pub KdflvStr: u16,
    pub Reserved3: [u8; 9usize],
    pub UserExtra: u8,
    pub UserExtraAdd: u8,
    pub LockValue: u8,
    pub LockConfig: u8,
    pub SlotLocked: u16,
    pub ChipOptions: u16,
    pub X509format: u32,
    pub KeyConfig: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_atecc608_config_s() {
    const UNINIT: ::core::mem::MaybeUninit<atecc608_config_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atecc608_config_s>(),
        128usize,
        concat!("Size of: ", stringify!(atecc608_config_s))
    );
    assert_eq!(
        ::core::mem::align_of::<atecc608_config_s>(),
        1usize,
        concat!("Alignment of ", stringify!(atecc608_config_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN03) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SN03)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RevNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(RevNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN47) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SN47)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SN8) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SN8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AES_Enable) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(AES_Enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Enable) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(I2C_Enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(I2C_Address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CountMatch) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(CountMatch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChipMode) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(ChipMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotConfig) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SlotConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter0) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(Counter0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Counter1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(Counter1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UseLock) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(UseLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolatileKeyPermission) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(VolatileKeyPermission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecureBoot) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SecureBoot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KdflvLoc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(KdflvLoc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KdflvStr) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(KdflvStr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserExtra) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(UserExtra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserExtraAdd) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(UserExtraAdd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockValue) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(LockValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockConfig) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(LockConfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotLocked) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(SlotLocked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChipOptions) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(ChipOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).X509format) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(X509format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KeyConfig) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(atecc608_config_s),
            "::",
            stringify!(KeyConfig)
        )
    );
}
pub type atecc608_config_t = atecc608_config_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ATCAPacket {
    pub reserved: u8,
    pub txsize: u8,
    pub opcode: u8,
    pub param1: u8,
    pub param2: u16,
    pub data: [u8; 192usize],
    pub execTime: u8,
}
#[test]
fn bindgen_test_layout_ATCAPacket() {
    const UNINIT: ::core::mem::MaybeUninit<ATCAPacket> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ATCAPacket>(),
        200usize,
        concat!("Size of: ", stringify!(ATCAPacket))
    );
    assert_eq!(
        ::core::mem::align_of::<ATCAPacket>(),
        2usize,
        concat!("Alignment of ", stringify!(ATCAPacket))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txsize) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(txsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(param1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(param2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execTime) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(ATCAPacket),
            "::",
            stringify!(execTime)
        )
    );
}
extern "C" {
    pub fn atCheckMAC(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atCounter(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atDeriveKey(
        device_type: ATCADeviceType,
        packet: *mut ATCAPacket,
        has_mac: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atECDH(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atGenDig(
        device_type: ATCADeviceType,
        packet: *mut ATCAPacket,
        is_no_mac_key: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atGenKey(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atInfo(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atLock(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atMAC(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atNonce(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atPause(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atPrivWrite(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atRandom(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atRead(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSecureBoot(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSHA(
        device_type: ATCADeviceType,
        packet: *mut ATCAPacket,
        write_context_size: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSign(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atUpdateExtra(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atVerify(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atWrite(
        device_type: ATCADeviceType,
        packet: *mut ATCAPacket,
        has_mac: bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atAES(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atSelfTest(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atKDF(device_type: ATCADeviceType, packet: *mut ATCAPacket) -> ATCA_STATUS;
}
extern "C" {
    pub fn atIsSHAFamily(device_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn atIsECCFamily(device_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn isATCAError(data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atCRC(length: usize, data: *const u8, crc_le: *mut u8);
}
extern "C" {
    pub fn atCalcCrc(packet: *mut ATCAPacket);
}
extern "C" {
    pub fn atCheckCrc(response: *const u8) -> ATCA_STATUS;
}
#[doc = " \\brief Structure to hold the device execution time and the opcode for the\n         corresponding command"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_execution_time_t {
    pub opcode: u8,
    pub execution_time_msec: u16,
}
#[test]
fn bindgen_test_layout_device_execution_time_t() {
    const UNINIT: ::core::mem::MaybeUninit<device_execution_time_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<device_execution_time_t>(),
        4usize,
        concat!("Size of: ", stringify!(device_execution_time_t))
    );
    assert_eq!(
        ::core::mem::align_of::<device_execution_time_t>(),
        2usize,
        concat!("Alignment of ", stringify!(device_execution_time_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_execution_time_t),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execution_time_msec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(device_execution_time_t),
            "::",
            stringify!(execution_time_msec)
        )
    );
}
extern "C" {
    pub fn calib_get_execution_time(opcode: u8, device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_execute_send(
        device: ATCADevice,
        device_address: u8,
        txdata: *mut u8,
        txlength: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_execute_receive(
        device: ATCADevice,
        device_address: u8,
        rxdata: *mut u8,
        rxlength: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_execute_command(packet: *mut ATCAPacket, device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_wakeup_i2c(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_wakeup(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_idle(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sleep(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_exit(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_get_addr(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        addr: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_get_zone_size(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        size: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ca2_get_addr(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        addr: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_is_locked(device: ATCADevice, zone: u8, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_is_slot_locked(device: ATCADevice, slot: u16, is_locked: *mut bool)
        -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ca2_is_locked(device: ATCADevice, zone: u8, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ca2_is_data_locked(device: ATCADevice, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ca2_is_config_locked(device: ATCADevice, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_get_devicetype(revision: *mut u8) -> ATCADeviceType;
}
extern "C" {
    pub fn calib_is_locked_ext(device: ATCADevice, zone: u8, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_is_private(device: ATCADevice, slot: u16, is_private: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        aes_in: *const u8,
        aes_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_encrypt(
        device: ATCADevice,
        key_id: u16,
        key_block: u8,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_decrypt(
        device: ATCADevice,
        key_id: u16,
        key_block: u8,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gfm(
        device: ATCADevice,
        h: *const u8,
        input: *const u8,
        output: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_checkmac_base(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
        resp_mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_checkmac(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_checkmac_with_response_mac(
        device: ATCADevice,
        mode: u8,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_counter(
        device: ATCADevice,
        mode: u8,
        counter_id: u16,
        counter_value: *mut u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_counter_increment(
        device: ATCADevice,
        counter_id: u16,
        counter_value: *mut u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_counter_read(
        device: ATCADevice,
        counter_id: u16,
        counter_value: *mut u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_derivekey(
        device: ATCADevice,
        mode: u8,
        target_key: u16,
        mac: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh_base(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh(
        device: ATCADevice,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh_tempkey(
        device: ATCADevice,
        public_key: *const u8,
        pms: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh_enc(
        device: ATCADevice,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        read_key: *const u8,
        read_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh_ioenc(
        device: ATCADevice,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_ecdh_tempkey_ioenc(
        device: ATCADevice,
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_gendig(
        device: ATCADevice,
        zone: u8,
        key_id: u16,
        other_data: *const u8,
        other_data_size: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_genkey_base(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        other_data: *const u8,
        public_key: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_genkey(device: ATCADevice, key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_get_pubkey(device: ATCADevice, key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_genkey_mac(device: ATCADevice, public_key: *mut u8, mac: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_info_base(
        device: ATCADevice,
        mode: u8,
        param2: u16,
        out_data: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_info(device: ATCADevice, revision: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_info_privkey_valid(
        device: ATCADevice,
        key_id: u16,
        is_valid: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_info_set_latch(device: ATCADevice, state: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_info_get_latch(device: ATCADevice, state: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_kdf(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        details: u32,
        message: *const u8,
        out_data: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock(device: ATCADevice, mode: u8, summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock_config_zone(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock_config_zone_crc(device: ATCADevice, summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock_data_zone(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock_data_zone_crc(device: ATCADevice, summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_lock_data_slot(device: ATCADevice, slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_mac(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        challenge: *const u8,
        digest: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_nonce_base(
        device: ATCADevice,
        mode: u8,
        param2: u16,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_nonce(device: ATCADevice, num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_nonce_load(
        device: ATCADevice,
        target: u8,
        num_in: *const u8,
        num_in_size: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_nonce_rand(
        device: ATCADevice,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_challenge(device: ATCADevice, num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_challenge_seed_update(
        device: ATCADevice,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_nonce_gen_session_key(
        device: ATCADevice,
        param2: u16,
        num_in: *mut u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_get_numin_size(mode: u8, length: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_priv_write(
        device: ATCADevice,
        key_id: u16,
        priv_key: *const u8,
        write_key_id: u16,
        write_key: *const u8,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_random(device: ATCADevice, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_zone(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *mut u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_bytes_zone(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset: usize,
        data: *mut u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_serial_number(device: ATCADevice, serial_number: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_compare_config(expected: *mut u8, other: *mut u8) -> bool;
}
extern "C" {
    pub fn calib_ecc_compare_config(expected: *mut u8, other: *mut u8) -> bool;
}
extern "C" {
    pub fn calib_ecc608_compare_config(expected: *mut u8, other: *mut u8) -> bool;
}
extern "C" {
    pub fn calib_read_sig(device: ATCADevice, slot: u16, sig: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_config_zone(device: ATCADevice, config_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_cmp_config_zone(
        device: ATCADevice,
        config_data: *mut u8,
        same_config: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *mut u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_bytes_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset: usize,
        data: *mut u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_pubkey(device: ATCADevice, slot: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_serial_number_ext(device: ATCADevice, serial_number: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_read_enc(
        device: ATCADevice,
        key_id: u16,
        block: u8,
        data: *mut u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_secureboot(
        device: ATCADevice,
        mode: u8,
        param2: u16,
        digest: *const u8,
        signature: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_secureboot_mac(
        device: ATCADevice,
        mode: u8,
        digest: *const u8,
        signature: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_selftest(
        device: ATCADevice,
        mode: u8,
        param2: u16,
        result: *mut u8,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_sha256_ctx {
    #[doc = "!< Total number of message bytes processed"]
    pub total_msg_size: u32,
    #[doc = "!< Number of bytes in current block"]
    pub block_size: u32,
    #[doc = "!< Unprocessed message storage"]
    pub block: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_atca_sha256_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_sha256_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_sha256_ctx>(),
        136usize,
        concat!("Size of: ", stringify!(atca_sha256_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_sha256_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_sha256_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_msg_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(total_msg_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_sha256_ctx),
            "::",
            stringify!(block)
        )
    );
}
pub type atca_sha256_ctx_t = atca_sha256_ctx;
pub type atca_hmac_sha256_ctx_t = atca_sha256_ctx_t;
extern "C" {
    pub fn calib_sha_base(
        device: ATCADevice,
        mode: u8,
        length: u16,
        message: *const u8,
        data_out: *mut u8,
        data_out_size: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_start(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_update(device: ATCADevice, message: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_end(
        device: ATCADevice,
        digest: *mut u8,
        length: u16,
        message: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_read_context(
        device: ATCADevice,
        context: *mut u8,
        context_size: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_write_context(
        device: ATCADevice,
        context: *const u8,
        context_size: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha(
        device: ATCADevice,
        length: u16,
        message: *const u8,
        digest: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_hw_sha2_256(
        device: ATCADevice,
        data: *const u8,
        data_size: usize,
        digest: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_hw_sha2_256_init(device: ATCADevice, ctx: *mut atca_sha256_ctx_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_hw_sha2_256_update(
        device: ATCADevice,
        ctx: *mut atca_sha256_ctx_t,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_hw_sha2_256_finish(
        device: ATCADevice,
        ctx: *mut atca_sha256_ctx_t,
        digest: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_hmac_init(
        device: ATCADevice,
        ctx: *mut atca_hmac_sha256_ctx_t,
        key_slot: u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_hmac_update(
        device: ATCADevice,
        ctx: *mut atca_hmac_sha256_ctx_t,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_hmac_finish(
        device: ATCADevice,
        ctx: *mut atca_hmac_sha256_ctx_t,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sha_hmac(
        device: ATCADevice,
        data: *const u8,
        data_size: usize,
        key_slot: u16,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sign_base(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sign(
        device: ATCADevice,
        key_id: u16,
        msg: *const u8,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sign_ext(
        device: ATCADevice,
        key_id: u16,
        msg: *const u8,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_sign_internal(
        device: ATCADevice,
        key_id: u16,
        is_invalidate: bool,
        is_full_sn: bool,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_updateextra(device: ATCADevice, mode: u8, new_value: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        signature: *const u8,
        public_key: *const u8,
        other_data: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_extern(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_extern_mac(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_stored(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_stored_with_tempkey(
        device: ATCADevice,
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_stored_mac(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_validate(
        device: ATCADevice,
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_verify_invalidate(
        device: ATCADevice,
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write(
        device: ATCADevice,
        zone: u8,
        address: u16,
        value: *const u8,
        mac: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_zone(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *const u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_bytes_zone(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset_bytes: usize,
        data: *const u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_config_zone(device: ATCADevice, config_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_config_counter(
        device: ATCADevice,
        counter_id: u16,
        counter_value: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_ext(
        device: ATCADevice,
        zone: u8,
        address: u16,
        value: *const u8,
        mac: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *const u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_bytes_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset_bytes: usize,
        data: *const u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_config_zone_ext(device: ATCADevice, config_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_config_counter_ext(
        device: ATCADevice,
        counter_id: u16,
        counter_value: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_pubkey(device: ATCADevice, slot: u16, public_key: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_write_enc(
        device: ATCADevice,
        key_id: u16,
        block: u8,
        data: *const u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub static mut atca_basic_aes_gcm_version: *const ::core::ffi::c_char;
}
#[doc = " Context structure for AES GCM operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_gcm_ctx {
    #[doc = "!< Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey."]
    pub key_id: u16,
    #[doc = "!< Index of the 16-byte block to use within the key location for the actual key."]
    pub key_block: u8,
    #[doc = "!< Counter block, comprises of nonce + count value (16 bytes)."]
    pub cb: [u8; 16usize],
    #[doc = "!< Size of the data being encrypted/decrypted in bytes."]
    pub data_size: u32,
    #[doc = "!< Size of the additional authenticated data in bytes."]
    pub aad_size: u32,
    #[doc = "!< Subkey for ghash functions in GCM."]
    pub h: [u8; 16usize],
    #[doc = "!< Precounter block generated from IV."]
    pub j0: [u8; 16usize],
    #[doc = "!< Current GHASH output"]
    pub y: [u8; 16usize],
    #[doc = "!< Partial blocks of data waiting to be processed"]
    pub partial_aad: [u8; 16usize],
    #[doc = "!< Amount of data in the partial block buffer"]
    pub partial_aad_size: u32,
    #[doc = "!< Last encrypted counter block"]
    pub enc_cb: [u8; 16usize],
    #[doc = "!< Last ciphertext block"]
    pub ciphertext_block: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_gcm_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_gcm_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_gcm_ctx>(),
        128usize,
        concat!("Size of: ", stringify!(atca_aes_gcm_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_gcm_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atca_aes_gcm_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_block) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aad_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(aad_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).j0) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(j0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_aad) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(partial_aad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_aad_size) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(partial_aad_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_cb) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(enc_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphertext_block) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_gcm_ctx),
            "::",
            stringify!(ciphertext_block)
        )
    );
}
#[doc = " Context structure for AES GCM operations."]
pub type atca_aes_gcm_ctx_t = atca_aes_gcm_ctx;
extern "C" {
    pub fn calib_aes_gcm_init(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
        iv_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_init_rand(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        key_id: u16,
        key_block: u8,
        rand_size: usize,
        free_field: *const u8,
        free_field_size: usize,
        iv: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_aad_update(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        aad: *const u8,
        aad_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_encrypt_update(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        plaintext: *const u8,
        plaintext_size: u32,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_encrypt_finish(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *mut u8,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_decrypt_update(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        ciphertext: *const u8,
        ciphertext_size: u32,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn calib_aes_gcm_decrypt_finish(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *const u8,
        tag_size: usize,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atcac_sha1_ctx {
    pub pad: [u32; 32usize],
}
#[test]
fn bindgen_test_layout_atcac_sha1_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atcac_sha1_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atcac_sha1_ctx>(),
        128usize,
        concat!("Size of: ", stringify!(atcac_sha1_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atcac_sha1_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atcac_sha1_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_sha1_ctx),
            "::",
            stringify!(pad)
        )
    );
}
pub type atcac_sha1_ctx_t = atcac_sha1_ctx;
extern "C" {
    pub fn atcac_sw_sha1_init(ctx: *mut atcac_sha1_ctx) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sw_sha1_update(
        ctx: *mut atcac_sha1_ctx,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sw_sha1_finish(ctx: *mut atcac_sha1_ctx, digest: *mut u8) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atcac_sha2_256_ctx {
    pub pad: [u32; 48usize],
}
#[test]
fn bindgen_test_layout_atcac_sha2_256_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atcac_sha2_256_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atcac_sha2_256_ctx>(),
        192usize,
        concat!("Size of: ", stringify!(atcac_sha2_256_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atcac_sha2_256_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(atcac_sha2_256_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_sha2_256_ctx),
            "::",
            stringify!(pad)
        )
    );
}
pub type atcac_sha2_256_ctx_t = atcac_sha2_256_ctx;
extern "C" {
    pub fn atcac_sw_sha2_256_init(ctx: *mut atcac_sha2_256_ctx) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sw_sha2_256_update(
        ctx: *mut atcac_sha2_256_ctx,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sw_sha2_256_finish(ctx: *mut atcac_sha2_256_ctx, digest: *mut u8) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atcac_hmac_ctx {
    pub sha256_ctx: *mut atcac_sha2_256_ctx_t,
    pub ipad: [u8; 64usize],
    pub opad: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_atcac_hmac_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atcac_hmac_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atcac_hmac_ctx>(),
        136usize,
        concat!("Size of: ", stringify!(atcac_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atcac_hmac_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atcac_hmac_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_hmac_ctx),
            "::",
            stringify!(sha256_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_hmac_ctx),
            "::",
            stringify!(ipad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(atcac_hmac_ctx),
            "::",
            stringify!(opad)
        )
    );
}
pub type atcac_hmac_ctx_t = atcac_hmac_ctx;
extern "C" {
    pub fn atcac_sha256_hmac_init(
        ctx: *mut atcac_hmac_ctx,
        sha256_ctx: *mut atcac_sha2_256_ctx,
        key: *const u8,
        key_len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sha256_hmac_update(
        ctx: *mut atcac_hmac_ctx,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sha256_hmac_finish(
        ctx: *mut atcac_hmac_ctx,
        digest: *mut u8,
        digest_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_pbkdf2_sha256(
        iter: u32,
        password: *const u8,
        password_len: usize,
        salt: *const u8,
        salt_len: usize,
        result: *mut u8,
        result_len: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sw_sha2_256(data: *const u8, data_size: usize, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sha256_hmac_ctr_iteration(
        ctx: *mut atcac_hmac_ctx,
        iteration: u8,
        length: u16,
        label: *const u8,
        label_len: usize,
        data: *const u8,
        data_len: usize,
        digest: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_sha256_hmac_counter(
        key: *mut u8,
        key_len: usize,
        label: *const u8,
        label_len: usize,
        data: *const u8,
        data_len: usize,
        digest: *mut u8,
        diglen: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub static mut g_atcab_device_ptr: ATCADevice;
}
extern "C" {
    pub fn atcab_version(ver_str: *mut ::core::ffi::c_char) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_init_ext(device: *mut ATCADevice, cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_init(cfg: *mut ATCAIfaceCfg) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_init_device(ca_device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_release_ext(device: *mut ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_release() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_device() -> ATCADevice;
}
extern "C" {
    pub fn atcab_get_device_type_ext(device: ATCADevice) -> ATCADeviceType;
}
extern "C" {
    pub fn atcab_get_device_type() -> ATCADeviceType;
}
extern "C" {
    pub fn atcab_get_device_address(device: ATCADevice) -> u8;
}
extern "C" {
    pub fn atcab_is_ca_device(dev_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn atcab_is_ca2_device(dev_type: ATCADeviceType) -> bool;
}
extern "C" {
    pub fn atcab_is_ta_device(dev_type: ATCADeviceType) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_cbc_ctx {
    #[doc = "!< Device Context Pointer"]
    pub device: ATCADevice,
    #[doc = "!< Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey."]
    pub key_id: u16,
    #[doc = "!< Index of the 16-byte block to use within the key location for the actual key."]
    pub key_block: u8,
    #[doc = "!< Ciphertext from last operation."]
    pub ciphertext: [u8; 16usize],
    #[doc = "!< Number of bytes in unprocessed block."]
    pub block_size: u8,
    #[doc = "!< Unprocessed message storage."]
    pub block: [u8; 16usize],
    #[doc = "!< Is padding expected"]
    pub padding: u8,
}
#[test]
fn bindgen_test_layout_atca_aes_cbc_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_cbc_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_cbc_ctx>(),
        48usize,
        concat!("Size of: ", stringify!(atca_aes_cbc_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_cbc_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_aes_cbc_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_block) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphertext) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(ciphertext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbc_ctx),
            "::",
            stringify!(padding)
        )
    );
}
pub type atca_aes_cbc_ctx_t = atca_aes_cbc_ctx;
extern "C" {
    pub fn atcab_aes_cbc_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_cbc_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
        padding: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_init(
        ctx: *mut atca_aes_cbc_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_encrypt_block(
        ctx: *mut atca_aes_cbc_ctx_t,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_decrypt_block(
        ctx: *mut atca_aes_cbc_ctx_t,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_encrypt_update(
        ctx: *mut atca_aes_cbc_ctx_t,
        plaintext: *mut u8,
        plaintext_len: usize,
        ciphertext: *mut u8,
        ciphertext_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_encrypt_finish(
        ctx: *mut atca_aes_cbc_ctx_t,
        ciphertext: *mut u8,
        ciphertext_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_decrypt_update(
        ctx: *mut atca_aes_cbc_ctx_t,
        ciphertext: *const u8,
        ciphertext_len: usize,
        plaintext: *mut u8,
        plaintext_len: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbc_decrypt_finish(
        ctx: *mut atca_aes_cbc_ctx_t,
        plaintext: *mut u8,
        plaintext_len: *mut usize,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_cmac_ctx {
    #[doc = "!< CBC context"]
    pub cbc_ctx: atca_aes_cbc_ctx_t,
    #[doc = "!< Number of bytes in current block."]
    pub block_size: u32,
    #[doc = "!< Unprocessed message storage."]
    pub block: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_cmac_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_cmac_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_cmac_ctx>(),
        72usize,
        concat!("Size of: ", stringify!(atca_aes_cmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_cmac_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_aes_cmac_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbc_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(cbc_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cmac_ctx),
            "::",
            stringify!(block)
        )
    );
}
pub type atca_aes_cmac_ctx_t = atca_aes_cmac_ctx;
extern "C" {
    pub fn atcab_aes_cmac_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_cmac_ctx_t,
        key_id: u16,
        key_block: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cmac_init(
        ctx: *mut atca_aes_cmac_ctx_t,
        key_id: u16,
        key_block: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cmac_update(
        ctx: *mut atca_aes_cmac_ctx_t,
        data: *const u8,
        data_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cmac_finish(
        ctx: *mut atca_aes_cmac_ctx_t,
        cmac: *mut u8,
        cmac_size: u32,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_ctr_ctx {
    #[doc = "!< Device Context Pointer"]
    pub device: ATCADevice,
    #[doc = "!< Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey."]
    pub key_id: u16,
    #[doc = "!< Index of the 16-byte block to use within the key location for the actual key."]
    pub key_block: u8,
    #[doc = "!< Counter block, comprises of nonce + count value (16 bytes)."]
    pub cb: [u8; 16usize],
    #[doc = "!< Size of counter in the initialization vector."]
    pub counter_size: u8,
}
#[test]
fn bindgen_test_layout_atca_aes_ctr_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_ctr_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_ctr_ctx>(),
        32usize,
        concat!("Size of: ", stringify!(atca_aes_ctr_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_ctr_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_aes_ctr_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_block) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(key_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter_size) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ctr_ctx),
            "::",
            stringify!(counter_size)
        )
    );
}
pub type atca_aes_ctr_ctx_t = atca_aes_ctr_ctx;
extern "C" {
    pub fn atcab_aes_ctr_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_init(
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_init_rand_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_init_rand(
        ctx: *mut atca_aes_ctr_ctx_t,
        key_id: u16,
        key_block: u8,
        counter_size: u8,
        iv: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        input: *const u8,
        output: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_encrypt_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_decrypt_block(
        ctx: *mut atca_aes_ctr_ctx_t,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ctr_increment(ctx: *mut atca_aes_ctr_ctx_t) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_cbcmac_ctx {
    #[doc = "!< CBC context"]
    pub cbc_ctx: atca_aes_cbc_ctx_t,
    #[doc = "!< Number of bytes in unprocessed block."]
    pub block_size: u8,
    #[doc = "!< Unprocessed message storage."]
    pub block: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_cbcmac_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_cbcmac_ctx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_cbcmac_ctx>(),
        72usize,
        concat!("Size of: ", stringify!(atca_aes_cbcmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_cbcmac_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_aes_cbcmac_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbc_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbcmac_ctx),
            "::",
            stringify!(cbc_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbcmac_ctx),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_cbcmac_ctx),
            "::",
            stringify!(block)
        )
    );
}
pub type atca_aes_cbcmac_ctx_t = atca_aes_cbcmac_ctx;
extern "C" {
    pub fn atcab_aes_cbcmac_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_cbcmac_ctx_t,
        key_id: u16,
        key_block: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbcmac_init(
        ctx: *mut atca_aes_cbcmac_ctx_t,
        key_id: u16,
        key_block: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbcmac_update(
        ctx: *mut atca_aes_cbcmac_ctx_t,
        data: *const u8,
        data_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_cbcmac_finish(
        ctx: *mut atca_aes_cbcmac_ctx_t,
        mac: *mut u8,
        mac_size: u32,
    ) -> ATCA_STATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atca_aes_ccm_ctx {
    #[doc = "!< CBC_MAC context"]
    pub cbc_mac_ctx: atca_aes_cbcmac_ctx_t,
    #[doc = "!< CTR context"]
    pub ctr_ctx: atca_aes_ctr_ctx_t,
    #[doc = "!< iv size"]
    pub iv_size: u8,
    #[doc = "!< Tag size"]
    pub M: u8,
    #[doc = "!< Initial counter value"]
    pub counter: [u8; 16usize],
    #[doc = "!< Partial blocks of data waiting to be processed"]
    pub partial_aad: [u8; 16usize],
    #[doc = "!< Amount of data in the partial block buffer"]
    pub partial_aad_size: usize,
    #[doc = "!< Size of data to be processed"]
    pub text_size: usize,
    #[doc = "!< Last encrypted counter block"]
    pub enc_cb: [u8; 16usize],
    #[doc = "!< Size of the data being encrypted/decrypted in bytes."]
    pub data_size: u32,
    #[doc = "!< Last ciphertext block"]
    pub ciphertext_block: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_atca_aes_ccm_ctx() {
    const UNINIT: ::core::mem::MaybeUninit<atca_aes_ccm_ctx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<atca_aes_ccm_ctx>(),
        200usize,
        concat!("Size of: ", stringify!(atca_aes_ccm_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<atca_aes_ccm_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(atca_aes_ccm_ctx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbc_mac_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(cbc_mac_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr_ctx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(ctr_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).M) as usize - ptr as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_aad) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(partial_aad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_aad_size) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(partial_aad_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_size) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(text_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_cb) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(enc_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ciphertext_block) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(atca_aes_ccm_ctx),
            "::",
            stringify!(ciphertext_block)
        )
    );
}
pub type atca_aes_ccm_ctx_t = atca_aes_ccm_ctx;
extern "C" {
    pub fn atcab_aes_ccm_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_ccm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *mut u8,
        iv_size: usize,
        aad_size: usize,
        text_size: usize,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_init(
        ctx: *mut atca_aes_ccm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *mut u8,
        iv_size: usize,
        aad_size: usize,
        text_size: usize,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_init_rand_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_ccm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *mut u8,
        iv_size: usize,
        aad_size: usize,
        text_size: usize,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_init_rand(
        ctx: *mut atca_aes_ccm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *mut u8,
        iv_size: usize,
        aad_size: usize,
        text_size: usize,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_aad_update(
        ctx: *mut atca_aes_ccm_ctx_t,
        aad: *const u8,
        aad_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_aad_finish(ctx: *mut atca_aes_ccm_ctx_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_encrypt_update(
        ctx: *mut atca_aes_ccm_ctx_t,
        plaintext: *const u8,
        plaintext_size: u32,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_decrypt_update(
        ctx: *mut atca_aes_ccm_ctx_t,
        ciphertext: *const u8,
        ciphertext_size: u32,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_encrypt_finish(
        ctx: *mut atca_aes_ccm_ctx_t,
        tag: *mut u8,
        tag_size: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_ccm_decrypt_finish(
        ctx: *mut atca_aes_ccm_ctx_t,
        tag: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_pkcs7_pad(
        buffer: *mut u8,
        buflen: *mut usize,
        datalen: usize,
        blocksize: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcac_pkcs7_unpad(buffer: *mut u8, buflen: *mut usize, blocksize: u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_pbkdf2_sha256_ext(
        device: ATCADevice,
        iter: u32,
        slot: u16,
        salt: *const u8,
        salt_len: usize,
        result: *mut u8,
        result_len: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_pbkdf2_sha256(
        iter: u32,
        slot: u16,
        salt: *const u8,
        salt_len: usize,
        result: *mut u8,
        result_len: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_wakeup() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_idle() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sleep() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_zone_size(zone: u8, slot: u16, size: *mut usize) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_zone_size_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        size: *mut usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes(mode: u8, key_id: u16, aes_in: *const u8, aes_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_encrypt(
        key_id: u16,
        key_block: u8,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_encrypt_ext(
        device: ATCADevice,
        key_id: u16,
        key_block: u8,
        plaintext: *const u8,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_decrypt(
        key_id: u16,
        key_block: u8,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_decrypt_ext(
        device: ATCADevice,
        key_id: u16,
        key_block: u8,
        ciphertext: *const u8,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gfm(h: *const u8, input: *const u8, output: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_init(
        ctx: *mut atca_aes_gcm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
        iv_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_init_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        key_id: u16,
        key_block: u8,
        iv: *const u8,
        iv_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_init_rand(
        ctx: *mut atca_aes_gcm_ctx_t,
        key_id: u16,
        key_block: u8,
        rand_size: usize,
        free_field: *const u8,
        free_field_size: usize,
        iv: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_aad_update(
        ctx: *mut atca_aes_gcm_ctx_t,
        aad: *const u8,
        aad_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_aad_update_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        aad: *const u8,
        aad_size: u32,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_encrypt_update(
        ctx: *mut atca_aes_gcm_ctx_t,
        plaintext: *const u8,
        plaintext_size: u32,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_encrypt_update_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        plaintext: *const u8,
        plaintext_size: u32,
        ciphertext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_encrypt_finish(
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *mut u8,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_encrypt_finish_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *mut u8,
        tag_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_decrypt_update(
        ctx: *mut atca_aes_gcm_ctx_t,
        ciphertext: *const u8,
        ciphertext_size: u32,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_decrypt_update_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        ciphertext: *const u8,
        ciphertext_size: u32,
        plaintext: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_decrypt_finish(
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *const u8,
        tag_size: usize,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_aes_gcm_decrypt_finish_ext(
        device: ATCADevice,
        ctx: *mut atca_aes_gcm_ctx_t,
        tag: *const u8,
        tag_size: usize,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_checkmac(
        mode: u8,
        key_id: u16,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_checkmac_with_response_mac(
        mode: u8,
        challenge: *const u8,
        response: *const u8,
        other_data: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter(mode: u8, counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter_increment(counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_counter_read(counter_id: u16, counter_value: *mut u32) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_derivekey(mode: u8, key_id: u16, mac: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_derivekey_ext(
        device: ATCADevice,
        mode: u8,
        key_id: u16,
        mac: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_base(
        mode: u8,
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh(key_id: u16, public_key: *const u8, pms: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_enc(
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        read_key: *const u8,
        read_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_ioenc(
        key_id: u16,
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_tempkey(public_key: *const u8, pms: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_ecdh_tempkey_ioenc(
        public_key: *const u8,
        pms: *mut u8,
        io_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_gendig(
        zone: u8,
        key_id: u16,
        other_data: *const u8,
        other_data_size: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_gendivkey(other_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_genkey_base(
        mode: u8,
        key_id: u16,
        other_data: *const u8,
        public_key: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_genkey(key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_genkey_ext(device: ATCADevice, key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_pubkey(key_id: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_get_pubkey_ext(
        device: ATCADevice,
        key_id: u16,
        public_key: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hmac(mode: u8, key_id: u16, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_base(mode: u8, param2: u16, out_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info(revision: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_ext(device: ATCADevice, revision: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_lock_status(param2: u16, is_locked: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_chip_status(chip_status: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_set_latch(state: bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_info_get_latch(state: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_kdf(
        mode: u8,
        key_id: u16,
        details: u32,
        message: *const u8,
        out_data: *mut u8,
        out_nonce: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock(mode: u8, summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_config_zone() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_config_zone_ext(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_config_zone_crc(summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_zone() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_zone_ext(device: ATCADevice) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_zone_crc(summary_crc: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_slot(slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_lock_data_slot_ext(device: ATCADevice, slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_mac(mode: u8, key_id: u16, challenge: *const u8, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_base(
        mode: u8,
        zero: u16,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce(num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_load(target: u8, num_in: *const u8, num_in_size: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_rand(num_in: *const u8, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_nonce_rand_ext(
        device: ATCADevice,
        num_in: *const u8,
        rand_out: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_challenge(num_in: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_challenge_seed_update(num_in: *const u8, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_priv_write(
        key_id: u16,
        priv_key: *const u8,
        write_key_id: u16,
        write_key: *const u8,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_random(rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_random_ext(device: ATCADevice, rand_out: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_zone(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *mut u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_locked(zone: u8, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_config_locked(is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_config_locked_ext(device: ATCADevice, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_data_locked(is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_data_locked_ext(device: ATCADevice, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_slot_locked(slot: u16, is_locked: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_slot_locked_ext(
        device: ATCADevice,
        slot: u16,
        is_locked: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_private_ext(
        device: ATCADevice,
        slot: u16,
        is_private: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_is_private(slot: u16, is_private: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_bytes_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset: usize,
        data: *mut u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_bytes_zone(
        zone: u8,
        slot: u16,
        offset: usize,
        data: *mut u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_serial_number(serial_number: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_serial_number_ext(device: ATCADevice, serial_number: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_pubkey(slot: u16, public_key: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_pubkey_ext(device: ATCADevice, slot: u16, public_key: *mut u8)
        -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_sig(slot: u16, sig: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_config_zone(config_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_config_zone_ext(device: ATCADevice, config_data: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_cmp_config_zone(config_data: *mut u8, same_config: *mut bool) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_read_enc(
        key_id: u16,
        block: u8,
        data: *mut u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_secureboot(
        mode: u8,
        param2: u16,
        digest: *const u8,
        signature: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_secureboot_mac(
        mode: u8,
        digest: *const u8,
        signature: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_selftest(mode: u8, param2: u16, result: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_base(
        mode: u8,
        length: u16,
        data_in: *const u8,
        data_out: *mut u8,
        data_out_size: *mut u16,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_start() -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_update(message: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_end(digest: *mut u8, length: u16, message: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_read_context(context: *mut u8, context_size: *mut u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_write_context(context: *const u8, context_size: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha(length: u16, message: *const u8, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256(data: *const u8, data_size: usize, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_init(ctx: *mut atca_sha256_ctx_t) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_update(
        ctx: *mut atca_sha256_ctx_t,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_hw_sha2_256_finish(ctx: *mut atca_sha256_ctx_t, digest: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_init(ctx: *mut atca_hmac_sha256_ctx_t, key_slot: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_update(
        ctx: *mut atca_hmac_sha256_ctx_t,
        data: *const u8,
        data_size: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_finish(
        ctx: *mut atca_hmac_sha256_ctx_t,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac(
        data: *const u8,
        data_size: usize,
        key_slot: u16,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sha_hmac_ext(
        device: ATCADevice,
        data: *const u8,
        data_size: usize,
        key_slot: u16,
        digest: *mut u8,
        target: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign_base(mode: u8, key_id: u16, signature: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign(key_id: u16, msg: *const u8, signature: *mut u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign_ext(
        device: ATCADevice,
        key_id: u16,
        msg: *const u8,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_sign_internal(
        key_id: u16,
        is_invalidate: bool,
        is_full_sn: bool,
        signature: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_updateextra(mode: u8, new_value: u16) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify(
        mode: u8,
        key_id: u16,
        signature: *const u8,
        public_key: *const u8,
        other_data: *const u8,
        mac: *mut u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_extern(
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_extern_ext(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_extern_mac(
        message: *const u8,
        signature: *const u8,
        public_key: *const u8,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored(
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored_ext(
        device: ATCADevice,
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored_with_tempkey(
        signature: *const u8,
        key_id: u16,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_stored_mac(
        message: *const u8,
        signature: *const u8,
        key_id: u16,
        num_in: *const u8,
        io_key: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_validate(
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_verify_invalidate(
        key_id: u16,
        signature: *const u8,
        other_data: *const u8,
        is_verified: *mut bool,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write(zone: u8, address: u16, value: *const u8, mac: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_zone(
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *const u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        block: u8,
        offset: u8,
        data: *const u8,
        len: u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_bytes_zone_ext(
        device: ATCADevice,
        zone: u8,
        slot: u16,
        offset_bytes: usize,
        data: *const u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_bytes_zone(
        zone: u8,
        slot: u16,
        offset_bytes: usize,
        data: *const u8,
        length: usize,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_pubkey(slot: u16, public_key: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_pubkey_ext(
        device: ATCADevice,
        slot: u16,
        public_key: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_config_zone(config_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_config_zone_ext(device: ATCADevice, config_data: *const u8) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_enc(
        key_id: u16,
        block: u8,
        data: *const u8,
        enc_key: *const u8,
        enc_key_id: u16,
        num_in: *const u8,
    ) -> ATCA_STATUS;
}
extern "C" {
    pub fn atcab_write_config_counter(counter_id: u16, counter_value: u32) -> ATCA_STATUS;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
